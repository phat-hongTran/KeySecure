<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lime.Protocol</name>
    </assembly>
    <members>
        <member name="T:Lime.Protocol.Client.ClientChannel">
            <summary>
            Defines a communication channel between a node and a server.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.#ctor(Lime.Protocol.Network.ITransport,System.TimeSpan,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Client.ClientChannel" /> class.
            </summary>
            <param name="transport">The transport to be used by the channel.</param>
            <param name="sendTimeout">The channel send timeout. Each send operation must be completed in the specified timeout or it will be canceled.</param>
            <param name="envelopeBufferSize">The number of envelopes to be buffered internally by the channel in the receive operations. If this limit is reached, the channel will not consume the transport until the buffer is consumed by the receive operations.</param>
            <param name="fillEnvelopeRecipients">if set to <c>true</c> [fill envelope recipients].</param>
            <param name="autoReplyPings">Indicates if the channel should reply automatically to ping request commands. In this case, the ping command are not returned by the ReceiveCommandAsync method.</param>
            <param name="autoNotifyReceipt">Indicates if the client should automatically send 'received' notifications for messages.</param>
            <param name="remotePingInterval">The interval to ping the remote party.</param>
            <param name="remoteIdleTimeout">The timeout to close the channel due to inactivity.</param>
            <param name="consumeTimeout">The channel consume timeout. Each envelope received from the transport must be consumed in the specified interval or it will cause the channel to be closed.</param>
            <param name="closeTimeout">The channel close timeout.</param>
            <param name="channelCommandProcessor">The channel command processor.</param>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.StartNewSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Sends a new session envelope
            to the server and awaits for
            the response.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Cannot await for a session response since there's already a listener.</exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.NegotiateSessionAsync(Lime.Protocol.SessionCompression,Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Sends a negotiate session envelope
            to accepts the session negotiation options
            and awaits for the server confirmation.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="sessionCompression">The session compression option</param>
            <param name="sessionEncryption">The session encryption option</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.ReceiveAuthenticatingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a authenticating session envelope
            from the server, after a session negotiation.
            </summary>
            <param name="cancellationToken"></param>
            <returns>
            An authenticating session envelope or a failed session envelope.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.AuthenticateSessionAsync(Lime.Protocol.Identity,Lime.Protocol.Security.Authentication,System.String,System.Threading.CancellationToken)">
            <summary>
            Send a authenticate session envelope to the server to establish an authenticated session and awaits for the response.
            </summary>
            <param name="cancellationToken"></param>
            <param name="identity"></param>
            <param name="authentication"></param>
            <param name="instance"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            identity
            or
            authentication
            </exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.SendReceivedNotificationAsync(System.String,Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Notify to the server that
            the specified message was received
            by the peer
            </summary>
            <param name="messageId"></param>
            <param name="to"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">to</exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.SendFinishingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Sends a finishing session 
            envelope to the server.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.ReceiveFinishedSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a finished session envelope
            from the server.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannel.ReceiveSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a session from the remote node.
            Avoid to use this method directly. Instead, use the Server or Client channel methods.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Client.ClientChannelBuilder">
            <summary>
            Helper class for building instances of <see cref="T:Lime.Protocol.Client.ClientChannel"/>.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.#ctor(System.Func{Lime.Protocol.Network.ITransport},System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Client.ClientChannelBuilder"/> class.
            </summary>
            <param name="transportFactory">The transport factory.</param>
            <param name="serverUri">The server URI.</param>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.ServerUri">
            <summary>
            Gets the server URI.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.SendTimeout">
            <summary>
            Gets the send timeout.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.ConsumeTimeout">
            <summary>
            Gets the channel consume timeout.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.CloseTimeout">
            <summary>
            Gets the channel close timeout.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.EnvelopeBufferSize">
            <summary>
            Gets the channel envelope buffer size.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.ClientChannelBuilder.ChannelCommandProcessor">
            <summary>
            Gets the channel command processor.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.Create``1(System.Uri)">
            <summary>
            Creates an instance of <see cref="T:Lime.Protocol.Client.ClientChannelBuilder"/> using the specified transport type.
            </summary>
            <typeparam name="TTransport">The type of the transport.</typeparam>
            <param name="serverUri">The server URI.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.Create(Lime.Protocol.Network.ITransport,System.Uri)">
            <summary>
            Creates an instance of <see cref="T:Lime.Protocol.Client.ClientChannelBuilder"/> using the specified transport.
            </summary>
            <param name="transport">The transport.</param>
            <param name="serverUri">The server URI.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.Create(System.Func{Lime.Protocol.Network.ITransport},System.Uri)">
            <summary>
            Creates an instance of <see cref="T:Lime.Protocol.Client.ClientChannelBuilder"/> using the specified transport factory.
            </summary>
            <param name="transportFactory">The transport factory.</param>
            <param name="serverUri">The server URI.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithSendTimeout(System.TimeSpan)">
            <summary>
            Sets the send timeout.
            </summary>
            <param name="sendTimeout">The send timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithConsumeTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            Sets the consume timeout.
            </summary>
            <param name="consumeTimeout">The consume timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithCloseTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            Sets the close timeout.
            </summary>
            <param name="closeTimeout">The close timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithBuffersLimit(System.Int32)">
            <summary>
            Sets the buffers limit.
            </summary>
            <param name="buffersLimit">The buffers limit.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithEnvelopeBufferSize(System.Int32)">
            <summary>
            Sets the envelope buffer size.
            </summary>
            <param name="envelopeBufferSize">The buffers limit.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.WithChannelCommandProcessor(Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Sets the channel command processor to be used.
            </summary>
            <param name="channelCommandProcessor">The channel command processor.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddMessageModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Message})">
            <summary>
            Adds a message module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddMessageModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Message}})">
            <summary>
            Adds a message module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddNotificationModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Notification})">
            <summary>
            Adds a notification module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddNotificationModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Notification}})">
            <summary>
            Adds a notification module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddCommandModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Command})">
            <summary>
            Adds a command module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddCommandModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Command}})">
            <summary>
            Adds a command module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.AddBuiltHandler(System.Func{Lime.Protocol.Client.IClientChannel,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Adds a handler to be executed after the channel is built.
            </summary>
            <param name="builtHandler">The handler to be executed.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.BuildAsync(System.Threading.CancellationToken)">
            <summary>
            Builds a <see cref="T:Lime.Protocol.Client.ClientChannel"/> instance connecting the transport.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelBuilder.CreateEstablishedClientChannelBuilder">
            <summary>
            Creates an <see cref="T:Lime.Protocol.Client.EstablishedClientChannelBuilder"/> to allow building and establishment of <see cref="T:Lime.Protocol.Client.ClientChannel"/> instances.
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Lime.Protocol.Client.ClientChannelExtensions">
            <summary>
            Helper extensions for the IClientChannel interface.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelExtensions.EstablishSessionAsync(Lime.Protocol.Client.IClientChannel,System.Func{Lime.Protocol.SessionCompression[],Lime.Protocol.SessionCompression},System.Func{Lime.Protocol.SessionEncryption[],Lime.Protocol.SessionEncryption},Lime.Protocol.Identity,System.Func{Lime.Protocol.Security.AuthenticationScheme[],Lime.Protocol.Security.Authentication,Lime.Protocol.Security.Authentication},System.String,System.Threading.CancellationToken)">
            <summary>
            Performs the session negotiation and authentication handshake.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.ClientChannelExtensions.FinishSessionAsync(Lime.Protocol.Client.IClientChannel,System.Threading.CancellationToken)">
            <summary>
            Performs the session finishing handshake.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Client.EstablishedClientChannelBuilder">
            <summary>
            Helper class for building instances of <see cref="T:Lime.Protocol.Client.ClientChannel"/> and handling the establishment of the session for the channel.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.#ctor(Lime.Protocol.Client.IClientChannelBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Client.EstablishedClientChannelBuilder"/> class.
            </summary>
            <param name="clientChannelBuilder">The client channel builder.</param>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.ChannelBuilder">
            <summary>
            Gets the associated channel builder.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.Identity">
            <summary>
            Gets the identity.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.Instance">
            <summary>
            Gets the instance.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.EstablishmentTimeout">
            <summary>
            Gets the establishment timeout
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.CompressionSelector">
            <summary>
            Gets the compression selector.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.EncryptionSelector">
            <summary>
            Gets the encryption selector.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.Authenticator">
            <summary>
            Gets the authenticator.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.EstablishedClientChannelBuilder.EstablishedHandlers">
            <summary>
            Gets the established handlers.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithEstablishmentTimeout(System.TimeSpan)">
            <summary>
            Sets the timeout to Build and establish a new session
            </summary>
            <param name="timeout">The timeout</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithCompression(Lime.Protocol.SessionCompression)">
            <summary>
            Sets the compression option to be used in the session establishment.
            </summary>
            <param name="compression">The compression.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithCompression(System.Func{Lime.Protocol.SessionCompression[],Lime.Protocol.SessionCompression})">
            <summary>
            Sets the compression selector to be used in the session establishment.
            </summary>
            <param name="compressionSelector">The compression selector.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithEncryption(Lime.Protocol.SessionEncryption)">
            <summary>
            Sets the encryption option to be used in the session establishment.
            </summary>
            <param name="encryption">The encryption.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithEncryption(System.Func{Lime.Protocol.SessionEncryption[],Lime.Protocol.SessionEncryption})">
            <summary>
            Sets the encryption selector to be used in the session establishment.
            </summary>
            <param name="encryptionSelector">The encryption selector.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithPlainAuthentication(System.String)">
            <summary>
            Sets the authentication password to be used in the session establishment.
            </summary>
            <param name="password">The authentication password, in plain text.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithKeyAuthentication(System.String)">
            <summary>
            Sets the authentication key to be used in the session establishment.
            </summary>
            <param name="key">The authentication key.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithAuthentication``1">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithAuthentication(Lime.Protocol.Security.Authentication)">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <param name="authentication">The authentication.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithAuthentication(System.Func{Lime.Protocol.Security.AuthenticationScheme[],Lime.Protocol.Security.Authentication,Lime.Protocol.Security.Authentication})">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <param name="authenticator">The authenticator.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithIdentity(Lime.Protocol.Identity)">
            <summary>
            Sets the identity to be used in the session establishment.
            </summary>
            <param name="identity">The identity to be used.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.WithInstance(System.String)">
            <summary>
            Sets the instance name to be used in the session establishment.
            </summary>
            <param name="instance">The instance to be used.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.AddEstablishedHandler(System.Func{Lime.Protocol.Client.IClientChannel,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Adds a handler to be executed after the channel is built and established.
            </summary>
            <param name="establishedHandler">The handler to be executed.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.Copy">
            <summary>
            Creates a copy of the current builder instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.EstablishedClientChannelBuilder.BuildAndEstablishAsync(System.Threading.CancellationToken)">
            <summary>
            Builds a <see cref="T:Lime.Protocol.Client.ClientChannel"/> instance and establish the session using the builder options.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Client.IClientChannel">
            <summary>
            Defines the communication channel
            between a client node and a server.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.StartNewSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Sends a new session envelope
            to the server and awaits for
            the response.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An negotiating session envelope, 
            an authenticating session envelope (if there's no need for negotiation) 
            or a failed session envelope.</returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.NegotiateSessionAsync(Lime.Protocol.SessionCompression,Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Sends a negotiate session envelope
            to accepts the session negotiation options
            and awaits for the server confirmation.
            </summary>
            <param name="sessionCompression">The session compression option</param>
            <param name="sessionEncryption">The session encryption option</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An negotiating session envelope or a failed session envelope.</returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.ReceiveAuthenticatingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a authenticating session envelope
            from the server, after a session negotiation.
            </summary>
            <param name="cancellationToken"></param>
            <returns>An authenticating session envelope or a failed session envelope.</returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.AuthenticateSessionAsync(Lime.Protocol.Identity,Lime.Protocol.Security.Authentication,System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a authenticate session envelope
            to the server to establish
            an authenticated session and awaits
            for the established session envelope.
            </summary>
            <param name="identity"></param>
            <param name="authentication"></param>
            <param name="instance"></param>
            <param name="cancellationToken"></param>
            <returns>An established session envelope or a failed session envelope.</returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.SendReceivedNotificationAsync(System.String,Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Notify to the server that
            the specified message was received
            by the peer
            </summary>
            <param name="messageId">The message identifier.</param>
            <param name="to">The notification destination.</param>
            <param name="cancellationToken"></param>
            <returns></returns>        
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.SendFinishingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Sends a finishing session 
            envelope to the server.
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannel.ReceiveFinishedSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a finished session envelope
            from the server. 
            </summary>
            <param name="cancellationToken"></param>
            <returns>An finished session envelope or a failed session envelope.</returns>
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.ServerUri">
            <summary>
            Gets the server URI.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.SendTimeout">
            <summary>
            Gets the channel send timeout.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.ConsumeTimeout">
            <summary>
            Gets the channel consume timeout.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.CloseTimeout">
            <summary>
            Gets the channel close timeout.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.EnvelopeBufferSize">
            <summary>
            Gets the buffers limit.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.IClientChannelBuilder.ChannelCommandProcessor">
            <summary>
            Gets the channel command processor.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.WithSendTimeout(System.TimeSpan)">
            <summary>
            Sets the send timeout.
            </summary>
            <param name="sendTimeout">The send timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.WithConsumeTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            Sets the consume timeout.
            </summary>
            <param name="consumeTimeout">The consume timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.WithCloseTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            Sets the close timeout.
            </summary>
            <param name="closeTimeout">The close timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.WithEnvelopeBufferSize(System.Int32)">
            <summary>
            Sets the envelope buffer size.
            </summary>
            <param name="envelopeBufferSize">The buffers limit.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.WithChannelCommandProcessor(Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Sets the channel command processor to be used.
            </summary>
            <param name="channelCommandProcessor">The channel command processor.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddMessageModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Message})">
            <summary>
            Adds a message module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddMessageModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Message}})">
            <summary>
            Adds a message module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddNotificationModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Notification})">
            <summary>
            Adds a notification module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddNotificationModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Notification}})">
            <summary>
            Adds a notification module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddCommandModule(Lime.Protocol.Network.IChannelModule{Lime.Protocol.Command})">
            <summary>
            Adds a command module to the channel.
            </summary>
            <param name="module">The module.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddCommandModule(System.Func{Lime.Protocol.Client.IClientChannel,Lime.Protocol.Network.IChannelModule{Lime.Protocol.Command}})">
            <summary>
            Adds a command module to the channel.
            </summary>
            <param name="moduleFactory">The module factory.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.AddBuiltHandler(System.Func{Lime.Protocol.Client.IClientChannel,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Adds a handler to be executed after the channel is built.
            </summary>
            <param name="builtHandler">The handler to be executed.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.BuildAsync(System.Threading.CancellationToken)">
            <summary>
            Builds a <see cref="T:Lime.Protocol.Client.ClientChannel"/> instance connecting the transport.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IClientChannelBuilder.CreateEstablishedClientChannelBuilder">
            <summary>
            Creates an <see cref="T:Lime.Protocol.Client.EstablishedClientChannelBuilder"/> to allow building and establishment of <see cref="T:Lime.Protocol.Client.ClientChannel"/> instances.
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.ChannelBuilder">
            <summary>
            Gets the associated channel builder.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.Identity">
            <summary>
            Gets the identity.
            </summary>        
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.Instance">
            <summary>
            Gets the instance.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.EstablishmentTimeout">
            <summary>
            Gets the establishment timeout
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.CompressionSelector">
            <summary>
            Gets the compression selector.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.EncryptionSelector">
            <summary>
            Gets the encryption selector.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.Authenticator">
            <summary>
            Gets the authenticator.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IEstablishedClientChannelBuilder.EstablishedHandlers">
            <summary>
            Gets the established handlers.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithEstablishmentTimeout(System.TimeSpan)">
            <summary>
            Sets the timeout to Build and establish a new session
            </summary>
            <param name="timeout">The timeout</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithCompression(Lime.Protocol.SessionCompression)">
            <summary>
            Sets the compression option to be used in the session establishment.
            </summary>
            <param name="compression">The compression.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithCompression(System.Func{Lime.Protocol.SessionCompression[],Lime.Protocol.SessionCompression})">
            <summary>
            Sets the compression selector to be used in the session establishment.
            </summary>
            <param name="compressionSelector">The compression selector.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithEncryption(Lime.Protocol.SessionEncryption)">
            <summary>
            Sets the encryption option to be used in the session establishment.
            </summary>
            <param name="encryption">The encryption.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithEncryption(System.Func{Lime.Protocol.SessionEncryption[],Lime.Protocol.SessionEncryption})">
            <summary>
            Sets the encryption selector to be used in the session establishment.
            </summary>
            <param name="encryptionSelector">The encryption selector.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithPlainAuthentication(System.String)">
            <summary>
            Sets the authentication password to be used in the session establishment.
            </summary>
            <param name="password">The authentication password, in plain text.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithKeyAuthentication(System.String)">
            <summary>
            Sets the authentication key to be used in the session establishment.
            </summary>
            <param name="key">The authentication key.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithExternalAuthentication(System.String,System.String)">
            <summary>
            Set the external authentication token to be used in the session establishment.
            </summary>
            <param name="token">The authentication token</param>
            <param name="issuer"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithTransportAuthentication(Lime.Protocol.Security.DomainRole)">
            <summary>
            Set the domain role to be used in the session establishment
            </summary>
            <param name="domainRole"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithAuthentication``1">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithAuthentication(Lime.Protocol.Security.Authentication)">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <param name="authentication">The authentication.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithAuthentication(System.Func{Lime.Protocol.Security.AuthenticationScheme[],Lime.Protocol.Security.Authentication,Lime.Protocol.Security.Authentication})">
            <summary>
            Sets the authentication to be used in the session establishment.
            </summary>
            <param name="authenticator">The authenticator.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithIdentity(Lime.Protocol.Identity)">
            <summary>
            Sets the identity to be used in the session establishment.
            </summary>
            <param name="identity">The identity to be used.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.WithInstance(System.String)">
            <summary>
            Sets the instance name to be used in the session establishment.
            </summary>
            <param name="instance">The instance to be used.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.AddEstablishedHandler(System.Func{Lime.Protocol.Client.IClientChannel,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Adds a handler to be executed after the channel is built and established.
            </summary>
            <param name="establishedHandler">The handler to be executed.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.Copy">
            <summary>
            Creates a copy of the current builder instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.IEstablishedClientChannelBuilder.BuildAndEstablishAsync(System.Threading.CancellationToken)">
            <summary>
            Builds a <see cref="T:Lime.Protocol.Client.ClientChannel"/> instance and establish the session using the builder options.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Client.IOnDemandClientChannel">
            <summary>
            Defines a client channel that manages the session state and connects to the server on demand.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.IEstablishedChannel" />
        </member>
        <member name="P:Lime.Protocol.Client.IOnDemandClientChannel.IsEstablished">
            <summary>
            Gets a value indicating whether this instance has an established client channel.
            </summary>        
        </member>
        <member name="M:Lime.Protocol.Client.IOnDemandClientChannel.EstablishAsync(System.Threading.CancellationToken)">
            <summary>
            Force the creation of an established client channel, if not established.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Client.IOnDemandClientChannel.ChannelCreatedHandlers">
            <summary>
            Gets the channel created handlers, which are called when a channel is created.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IOnDemandClientChannel.ChannelDiscardedHandlers">
            <summary>
            Gets the channel discarded handlers, which are called when a channel is discarded.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IOnDemandClientChannel.ChannelCreationFailedHandlers">
            <summary>
            Gets the channel creation failed handlers, which are called when the channel creation failed.
            Each handler must return <c>true</c> if the failure was handled and a channel should be created again or <c>false</c> if not, which causes the exception to be thrown to the caller.
            The default action is the recreation of a channel. If a single handler return <c>false</c>, no channel will not be recreated.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.IOnDemandClientChannel.ChannelOperationFailedHandlers">
            <summary>
            Gets the channel operation failed handlers, which are called when the channel fails during an operation.
            Each handler must return <c>true</c> if the failure was handled and a channel should be created again or <c>false</c> if not, which causes the exception to be thrown to the caller.
            The default action is the recreation of a channel. If a single handler return <c>false</c>, no channel will not be recreated.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.IOnDemandClientChannel.FinishAsync(System.Threading.CancellationToken)">
            <summary>
            Finishes the associated client channel, if established.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Client.MultiplexerClientChannel">
            <summary>
            Implements a client channel that hold multiple connections with the server and distribute the load between these channels.
            </summary>
            <seealso cref="T:Lime.Protocol.Client.IOnDemandClientChannel" />
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:Lime.Protocol.Client.MultiplexerClientChannel.#ctor(Lime.Protocol.Client.IEstablishedClientChannelBuilder,System.Int32,System.Int32,System.Int32,Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Client.MultiplexerClientChannel"/> class.
            </summary>
            <param name="builder">The channel builder.</param>
            <param name="count">The number of channels to create.</param>
            <param name="inputBufferSize">The input buffer bounded capacity.</param>
            <param name="outputBufferSize">The output buffer bounded capacity.</param>
            <param name="channelCommandProcessor">The workflow for processing commands.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Lime.Protocol.Client.OnDemandClientChannel">
            <summary>
            Defines a client channel that manages the session state and connects to the server on demand.
            </summary>
            <seealso cref="T:Lime.Protocol.Client.IOnDemandClientChannel" />
            <seealso cref="T:System.IDisposable" />
            <seealso cref="T:Lime.Protocol.Network.ICommandChannel" />
            <seealso cref="T:Lime.Protocol.Network.IMessageChannel" />
            <seealso cref="T:Lime.Protocol.Network.INotificationChannel" />
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.#ctor(Lime.Protocol.Client.IEstablishedClientChannelBuilder)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Client.OnDemandClientChannel"/> class.
            </summary>
            <param name="builder">The builder.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.SendCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Sends a command envelope to the remote node.
            </summary>
            <param name="command"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.ReceiveCommandAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a command from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.ProcessCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Processes the command asynchronous.
            </summary>
            <param name="requestCommand">The request command.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.SendMessageAsync(Lime.Protocol.Message,System.Threading.CancellationToken)">
            <summary>
            Sends a message to the remote node.
            </summary>
            <param name="message"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.ReceiveMessageAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a message from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.SendNotificationAsync(Lime.Protocol.Notification,System.Threading.CancellationToken)">
            <summary>
            Sends a notification to the remote node.
            </summary>
            <param name="notification"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.ReceiveNotificationAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a notification from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Client.OnDemandClientChannel.IsEstablished">
            <summary>
            Gets a value indicating whether this instance has an established client channel.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.EstablishAsync(System.Threading.CancellationToken)">
            <summary>
            Force the creation of an established client channel, if not established.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Client.OnDemandClientChannel.ChannelCreatedHandlers">
            <summary>
            Gets the channel created handlers, which are called when a channel is created.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.OnDemandClientChannel.ChannelDiscardedHandlers">
            <summary>
            Gets the channel discarded handlers, which are called when a channel is discarded.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.OnDemandClientChannel.ChannelCreationFailedHandlers">
            <summary>
            Gets the channel creation failed handlers, which are called when the channel creation failed.
            Each handler must return <c>true</c> if the failure was handled and a channel should be created again or <c>false</c> if not, which causes the exception to be thrown to the caller.
            The default action is the recreation of a channel. If a single handler return <c>false</c>, no channel will not be recreated.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Client.OnDemandClientChannel.ChannelOperationFailedHandlers">
            <summary>
            Gets the channel operation failed handlers, which are called when the channel fails during an operation.
            Each handler must return <c>true</c> if the failure was handled and a channel should be created again or <c>false</c> if not, which causes the exception to be thrown to the caller.
            The default action is the recreation of a channel. If a single handler return <c>false</c>, no channel will not be recreated.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Client.OnDemandClientChannel.FinishAsync(System.Threading.CancellationToken)">
            <summary>
            Finishes the associated client channel, if established.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Command">
            <summary>
            Allows the manipulation of node resources, like server session parameters or information related to the network nodes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Command.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Command"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Command.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Command"/> class.
            </summary>
            <param name="id">The command identifier.</param>
        </member>
        <member name="P:Lime.Protocol.Command.Uri">
            <summary>
            The universal identifier
            of the resource
            </summary>
        </member>
        <member name="P:Lime.Protocol.Command.Type">
            <summary>
             MIME declaration of the resource type of the command.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Command.Resource">
            <summary>
            Server resource that are subject
            of the command
            </summary>
        </member>
        <member name="P:Lime.Protocol.Command.Method">
            <summary>
            Action to be taken to the
            resource
            </summary>
        </member>
        <member name="P:Lime.Protocol.Command.Status">
            <summary>
            Indicates the status of 
            the action taken to the resource
            </summary>
        </member>
        <member name="P:Lime.Protocol.Command.Reason">
            <summary>
            Indicates a reason for
            the status
            </summary>
        </member>
        <member name="M:Lime.Protocol.Command.Lime#Protocol#IDocumentContainer#GetDocument">
            <summary>
            Gets the contained document.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.CommandMethod">
            <summary>
            Defines methods for the manipulation of resources.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Get">
            <summary>
            Gets an existing value of the resource.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Set">
            <summary>
            Creates or updates the value of the resource.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Delete">
            <summary>
            Deletes a value of the resource or the resource itself.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Subscribe">
            <summary>
            Subscribes to the resource, allowing the originator to be notified when the value of the resource changes in the destination.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Unsubscribe">
            <summary>
            Unsubscribes to the resource, signaling to the destination that the originator do not want to receive further notifications about the resource.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Observe">
            <summary>
            Notify the destination about a change in the resource value of the sender. 
            If the resource value is absent, it represent that the resource in the specified URI was deleted in the originator.
            This method is one way and the destination  SHOULD NOT send a response for it. 
            Because of that, a command envelope with this method MAY NOT have an id.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandMethod.Merge">
            <summary>
            Merges the resource document with an existing one. If the resource doesn't exists, it is created.
            </summary>
        </member>
        <member name="T:Lime.Protocol.CommandStatus">
            <summary>
            Represents the status
            of a resource operation
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandStatus.Pending">
            <summary>
            The resource action is pending.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandStatus.Success">
            <summary>
            The resource action was successfully executed.
            </summary>
        </member>
        <member name="F:Lime.Protocol.CommandStatus.Failure">
            <summary>
            The resource action has failed.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Document">
            <summary>
            Defines a entity with a <see cref="T:Lime.Protocol.MediaType"/>.
            </summary>
            <seealso cref="T:Lime.Protocol.IDocument" />
        </member>
        <member name="M:Lime.Protocol.Document.#ctor(Lime.Protocol.MediaType)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Document"/> class.
            </summary>
            <param name="mediaType">Type of the media.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Document.GetMediaType">
            <summary>
            Gets the type of the media for the document.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Document.op_Implicit(System.String)~Lime.Protocol.Document">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Document"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="T:Lime.Protocol.DocumentCollection">
            <summary>
            Represents a collection of documents.
            </summary>
        </member>
        <member name="M:Lime.Protocol.DocumentCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.DocumentCollection"/> class.
            </summary>
        </member>
        <member name="P:Lime.Protocol.DocumentCollection.Total">
            <summary>
            Gets or sets the total of items in the collection.
            The count refers to the original source collection, without any applied filter that may be applied in the items on this collection.
            </summary>
            <value>
            The total.
            </value>
        </member>
        <member name="P:Lime.Protocol.DocumentCollection.ItemType">
            <summary>
            Gets or sets the media type of all items of the collection..
            </summary>
            <value>
            The type of the item.
            </value>
        </member>
        <member name="P:Lime.Protocol.DocumentCollection.Items">
            <summary>
            Gets or sets the collection items.
            </summary>
            <value>
            The items.
            </value>
        </member>
        <member name="M:Lime.Protocol.DocumentCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Lime.Protocol.DocumentContainer">
            <summary>
            Represents a generic container for a document, providing a media type for the correct handling of its value by the nodes.
            This class can be used along with <see cref="T:Lime.Protocol.DocumentCollection"/> to traffic different document types in a single message.
            </summary>
            <seealso cref="T:Lime.Protocol.Document" />
        </member>
        <member name="M:Lime.Protocol.DocumentContainer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.DocumentContainer"/> class.
            </summary>
        </member>
        <member name="P:Lime.Protocol.DocumentContainer.Type">
            <summary>
            Gets the media type of the contained document.
            </summary>
            <value>
            The type.
            </value>
        </member>
        <member name="P:Lime.Protocol.DocumentContainer.Value">
            <summary>
            Gets or sets the contained document value.
            </summary>
            <value>
            The document.
            </value>
        </member>
        <member name="M:Lime.Protocol.DocumentContainer.Lime#Protocol#IDocumentContainer#GetDocument">
            <summary>
            Gets the contained document.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Envelope">
            <summary>
            Base class to all communication documents.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Envelope.Id">
            <summary>
            Gets or sets the identifier of the envelope.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Envelope.From">
            <summary>
            Gets or sets the identifier of the sender node of the envelope. 
            If a node receives an envelope without this value, it means that the envelope was originated by the remote party.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Envelope.Pp">
            <summary>
             Gets or sets the delegation node. Its an acronym for per procurationem. 
            Identifier of a delegate node (a node that received a permission to send on behalf of another). 
            Allows a node to send an envelope on behalf of another identity.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Envelope.To">
            <summary>
            Gets or sets the identifier of the destination node of the envelope. 
            If a node receives an envelope without this value, it means that the envelope is addressed to itself.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Envelope.Metadata">
            <summary>
            Additional information to be delivered with the envelope.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Envelope.MemberwiseClone">
            <summary>
            Creates a shallow copy of the current <see cref="T:Lime.Protocol.Envelope"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.EnvelopeExtensions">
            <summary>
            Utility extension methods for the <see cref="T:Lime.Protocol.Envelope"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToDocument(Lime.Protocol.Command,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.JsonDocument"/> from the specified <see cref="T:Lime.Protocol.Command"/>.
            </summary>
            <param name="command">The command.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToDocument(Lime.Protocol.Message,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.JsonDocument"/> from the specified <see cref="T:Lime.Protocol.Message"/>.
            </summary>
            <param name="message">The message.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToDocument(Lime.Protocol.Notification,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.JsonDocument"/> from the specified <see cref="T:Lime.Protocol.Notification"/>.
            </summary>
            <param name="notification">The notification.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToDocument``1(``0,Lime.Protocol.MediaType,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.JsonDocument"/> from the specified <see cref="!:T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="envelope">The envelope.</param>
            <param name="mediaType">Type of the media.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToMessage(Lime.Protocol.JsonDocument,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.Message"/> from the specified <see cref="T:Lime.Protocol.JsonDocument"/>.
            </summary>
            <param name="jsonDocument">The json document.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToCommand(Lime.Protocol.JsonDocument,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.Command"/> from the specified <see cref="T:Lime.Protocol.JsonDocument"/>.
            </summary>
            <param name="jsonDocument">The json document.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToNotification(Lime.Protocol.JsonDocument,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Lime.Protocol.Notification"/> from the specified <see cref="T:Lime.Protocol.JsonDocument"/>.
            </summary>
            <param name="jsonDocument">The json document.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ToEnvelope(Lime.Protocol.JsonDocument,Lime.Protocol.MediaType,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates an <see cref="T:Lime.Protocol.Envelope"/> from the specified <see cref="T:Lime.Protocol.JsonDocument"/>.
            </summary>
            <param name="jsonDocument">The json document.</param>
            <param name="mediaType">Type of the media.</param>
            <param name="jsonSerializer"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Unknown envelope media type</exception>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.ShallowCopy``1(``0)">
            <summary>
            Gets a shallow copy of the current <see cref="T:Lime.Protocol.Envelope"/>.
            </summary>
            <typeparam name="TEnvelope"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.EnvelopeExtensions.GetSender(Lime.Protocol.Envelope)">
            <summary>
            Gets the sender node of the envelope.
            </summary>
            <param name="envelope">The envelope.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.EnvelopeId">
            <summary>
            Utility class for generating envelope ids.
            </summary>
        </member>
        <member name="M:Lime.Protocol.EnvelopeId.NewId">
            <summary>
            Generates a new envelope identifier.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.EnvelopeType">
            <summary>
            Lists the protocol supported envelope types.
            </summary>
        </member>
        <member name="F:Lime.Protocol.EnvelopeType.Message">
            <summary>
            The message envelope type,
            used for content transport.
            </summary>
        </member>
        <member name="F:Lime.Protocol.EnvelopeType.Notification">
            <summary>
            The notification envelope type,
            used to notify events about messages.
            </summary>
        </member>
        <member name="F:Lime.Protocol.EnvelopeType.Command">
            <summary>
            The command envelope type,
            used for request/response request processing.
            </summary>
        </member>
        <member name="F:Lime.Protocol.EnvelopeType.Session">
            <summary>
            The session envelope type,
            used for the communication channel establishment.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Identity">
            <summary>
            Represents an identity in a domain.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Identity.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Identity"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Identity.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Identity"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="domain">The domain.</param>
        </member>
        <member name="P:Lime.Protocol.Identity.Name">
            <summary>
            Identity unique name on his domain.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Identity.Domain">
            <summary>
            Network domain name of the identity.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Identity.ToString">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Identity.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Identity.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Identity.op_Equality(Lime.Protocol.Identity,Lime.Protocol.Identity)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Identity.op_Inequality(Lime.Protocol.Identity,Lime.Protocol.Identity)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Identity.op_Implicit(System.String)~Lime.Protocol.Identity">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Identity"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Identity"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Identity.op_Implicit(Lime.Protocol.Identity)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.Identity"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="identity">The identity.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Identity.ToNode">
            <summary>
            Creates a Node instance based on the identity,
            with a null value for the instance property.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Identity.Parse(System.String)">
            <summary>
            Parses the string to a valid Identity.
            </summary>
            <param name="s">The s.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">s</exception>
            <exception cref="T:System.FormatException">Invalid identity format</exception>
        </member>
        <member name="M:Lime.Protocol.Identity.TryParse(System.String,Lime.Protocol.Identity@)">
            <summary>
            Tries to parse the string to a valid Identity.
            </summary>
            <param name="s">The s.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Identity.ToImmutableIdentity">
            <summary>
            Create a new instance of <see cref="T:Lime.Protocol.Immutable.Identity"/> which is immutable based on this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.IdentityDocument">
            <summary>
            Represents an identity document.
            </summary>
        </member>
        <member name="P:Lime.Protocol.IdentityDocument.Value">
            <summary>
            The value of the document
            </summary>
        </member>
        <member name="M:Lime.Protocol.IdentityDocument.Parse(System.String)">
            <summary>
            Parses the string to a 
            IdentityDocument instance.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.IDocument">
            <summary>
            Defines a entity with a <see cref="T:Lime.Protocol.MediaType"/>.
            </summary>
        </member>
        <member name="M:Lime.Protocol.IDocument.GetMediaType">
            <summary>
            Gets the type of the media for the document.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.IDocumentContainer">
            <summary>
            Defines a type that contains a <see cref="T:Lime.Protocol.Document"/> instance.
            </summary>
        </member>
        <member name="M:Lime.Protocol.IDocumentContainer.GetDocument">
            <summary>
            Gets the contained document.
            </summary>
        </member>
        <member name="T:Lime.Protocol.IIdentity">
            <summary>
            Represents an identity in a domain.
            </summary>
        </member>
        <member name="P:Lime.Protocol.IIdentity.Name">
            <summary>
            Identity unique name on his domain.
            </summary>
        </member>
        <member name="P:Lime.Protocol.IIdentity.Domain">
            <summary>
            Network domain name of the identity.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Immutable.Identity">
            <summary>
            Represents an identity in a domain.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Immutable.Identity"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="domain">The domain.</param>
        </member>
        <member name="P:Lime.Protocol.Immutable.Identity.Name">
            <summary>
            Identity unique name on his domain.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Immutable.Identity.Domain">
            <summary>
            Network domain name of the identity.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.ToString">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.op_Equality(Lime.Protocol.Immutable.Identity,Lime.Protocol.Immutable.Identity)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.op_Inequality(Lime.Protocol.Immutable.Identity,Lime.Protocol.Immutable.Identity)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.op_Implicit(System.String)~Lime.Protocol.Immutable.Identity">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Immutable.Identity"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Immutable.Identity"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.op_Implicit(Lime.Protocol.Immutable.Identity)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.Immutable.Identity"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="identity">The identity.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.ToNode">
            <summary>
            Creates a Node instance based on the identity,
            with a null value for the instance property.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.Parse(System.String)">
            <summary>
            Parses the string to a valid Identity.
            </summary>
            <param name="s">The s.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">s</exception>
            <exception cref="T:System.FormatException">Invalid identity format</exception>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.TryParse(System.String,Lime.Protocol.Immutable.Identity@)">
            <summary>
            Tries to parse the string to a valid Identity.
            </summary>
            <param name="s">The s.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.Copy(System.String,System.String)">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Identity.ToMutableIdentity">
            <summary>
            Create a new instance of <see cref="T:Lime.Protocol.Identity"/> which is mutable based on this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Immutable.Node">
            <summary>
            Represents an element of a network.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Immutable.Node"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="domain">The domain.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="P:Lime.Protocol.Immutable.Node.Instance">
            <summary>
            The name of the instance used by the node to connect to the network.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.ToString">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.op_Equality(Lime.Protocol.Immutable.Node,Lime.Protocol.Immutable.Node)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.op_Inequality(Lime.Protocol.Immutable.Node,Lime.Protocol.Immutable.Node)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.op_Implicit(System.String)~Lime.Protocol.Immutable.Node">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Immutable.Node"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Immutable.Node"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.op_Implicit(Lime.Protocol.Immutable.Node)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.Immutable.Node"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="node">The node.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.Parse(System.String)">
            <summary>
            Parses the string to a valid Node.
            </summary>
            <param name="s">The s.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">s</exception>
            <exception cref="T:System.FormatException">Invalid Peer format</exception>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.TryParse(System.String,Lime.Protocol.Immutable.Node@)">
            <summary>
            Tries to parse the string to a valid Node
            </summary>
            <param name="s">The s.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.ToIdentity">
            <summary>
            Creates an Identity instance based on the Node identity.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Immutable.Node.IsComplete">
            <summary>
            Indicates if the node is a complete representation, 
            with name, domain and instance.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.Copy(System.String,System.String,System.String)">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Immutable.Node.ToMutableNode">
            <summary>
            Create a new instance of <see cref="T:Lime.Protocol.Node"/> which is mutable based on this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.INode">
            <summary>
            Represents an element of a network.
            </summary>
        </member>
        <member name="P:Lime.Protocol.INode.Instance">
            <summary>
            The name of the instance used by the node to connect to the network.
            </summary>
        </member>
        <member name="T:Lime.Protocol.JsonDocument">
            <summary>
            Represents a generic JSON document.
            </summary>
        </member>
        <member name="M:Lime.Protocol.JsonDocument.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.JsonDocument"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.JsonDocument.#ctor(Lime.Protocol.MediaType)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.JsonDocument"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.JsonDocument.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object},Lime.Protocol.MediaType)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.JsonDocument"/> class.
            </summary>
        </member>
        <member name="T:Lime.Protocol.LimeUri">
            <summary>
            Represents an URI of the lime scheme.
            </summary>
        </member>
        <member name="M:Lime.Protocol.LimeUri.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.LimeUri"/> class.
            </summary>
            <param name="uriPath">The URI path.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">
            Invalid URI format
            </exception>
        </member>
        <member name="P:Lime.Protocol.LimeUri.Path">
            <summary>
            Fragment or complete
            URI path.
            </summary>
        </member>
        <member name="P:Lime.Protocol.LimeUri.IsRelative">
            <summary>
            Indicates if the path 
            is relative.
            </summary>
        </member>
        <member name="M:Lime.Protocol.LimeUri.ToUri">
            <summary>
            Convert the current
            absolute path to a Uri.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.LimeUri.ToUri(Lime.Protocol.Identity)">
            <summary>
            Convert the relative
            path to a Uri, using
            the identity as the
            URI authority.
            </summary>
            <param name="authority"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.LimeUri.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Lime.Protocol.LimeUri.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lime.Protocol.LimeUri.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.LimeUri.Parse(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Listeners.BufferedChannelListener.Dispose">
            <summary>
            Stops the listener tasks and releases any related resource.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Listeners.ChannelListener">
            <summary>
            Creates listener loop tasks that receive envelopes from the channel and calls a consumer delegate.
            A task is created for each envelope type.
            </summary>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:Lime.Protocol.Listeners.ChannelListener.#ctor(System.Func{Lime.Protocol.Message,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}},System.Func{Lime.Protocol.Notification,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}},System.Func{Lime.Protocol.Command,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Listeners.ChannelListener"/> class.
            </summary>
            <param name="messageConsumer">The message consumer.</param>
            <param name="notificationConsumer">The notification consumer.</param>
            <param name="commandConsumer">The command consumer.</param>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="M:Lime.Protocol.Listeners.ChannelListener.Start(Lime.Protocol.Network.IEstablishedReceiverChannel)">
            <summary>
            Starts the channel listener tasks.
            </summary>
            <param name="channel"></param>
        </member>
        <member name="M:Lime.Protocol.Listeners.ChannelListener.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Listeners.ChannelListener.MessageListenerTask">
            <summary>
            Gets the message listener task.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Listeners.ChannelListener.NotificationListenerTask">
            <summary>
            Gets the notification listener task.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Listeners.ChannelListener.CommandListenerTask">
            <summary>
            Gets the command listener task.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Listeners.ChannelListener.Dispose">
            <summary>
            Stops the listener tasks and releases any related resource.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Listeners.DataflowChannelListener">
            <summary>
            Listens to a <see cref="T:Lime.Protocol.Network.IChannel"/> instance and pushes the received envelopes to a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1"/>.
            </summary>
            <seealso cref="T:Lime.Protocol.Listeners.ChannelListener" />
        </member>
        <member name="M:Lime.Protocol.Listeners.DataflowChannelListener.#ctor(System.Threading.Tasks.Dataflow.ITargetBlock{Lime.Protocol.Message},System.Threading.Tasks.Dataflow.ITargetBlock{Lime.Protocol.Notification},System.Threading.Tasks.Dataflow.ITargetBlock{Lime.Protocol.Command})">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Listeners.DataflowChannelListener" /> class.
            </summary>
            <param name="messageTargetBlock">The message target block.</param>
            <param name="notificationTargetBlock">The notification target block.</param>
            <param name="commandTargetBlock">The command target block.</param>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="M:Lime.Protocol.Listeners.EventChannelListener.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Listeners.EventChannelListener"/> class.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Listeners.EventChannelListener.MessageReceived">
            <summary>
            Occurs when a <see cref="T:Lime.Protocol.Message"/> was received by the channel.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Listeners.EventChannelListener.NotificationReceived">
            <summary>
            Occurs when a <see cref="T:Lime.Protocol.Notification"/> was received by the channel.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Listeners.EventChannelListener.CommandReceived">
            <summary>
            Occurs when a <see cref="T:Lime.Protocol.Command"/> was received by the channel.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Listeners.IChannelListener">
            <summary>
            Defines a channel listener service.
            </summary>    
        </member>
        <member name="P:Lime.Protocol.Listeners.IChannelListener.MessageListenerTask">
            <summary>
            Gets the message listener task. 
            When completed, return the last unconsumed <see cref="T:Lime.Protocol.Message"/>, if there's any.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Listeners.IChannelListener.NotificationListenerTask">
            <summary>
            Gets the notification listener task.
            When completed, return the last unconsumed <see cref="T:Lime.Protocol.Notification"/>, if there's any.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Listeners.IChannelListener.CommandListenerTask">
            <summary>
            Gets the command listener task.
            When completed, return the last unconsumed <see cref="T:Lime.Protocol.Command"/>, if there's any.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Listeners.IChannelListener.Start(Lime.Protocol.Network.IEstablishedReceiverChannel)">
            <summary>
            Starts this instance.
            </summary>
            <param name="channel">The channel to be listened.</param>
        </member>
        <member name="M:Lime.Protocol.Listeners.IChannelListener.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="T:Lime.Protocol.MediaType">
            <summary>
            MIME media type representation.
            <a href="http://trac.tools.ietf.org/html/rfc2045" />
            </summary>
        </member>
        <member name="F:Lime.Protocol.MediaType.TextPlain">
            <summary>
            Represents the text/plain media type.
            </summary>
        </member>
        <member name="F:Lime.Protocol.MediaType.ApplicationJson">
            <summary>
            Represents the application/json media type.
            </summary>
        </member>
        <member name="M:Lime.Protocol.MediaType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.MediaType"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.MediaType.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.MediaType"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="subtype">The subtype.</param>
            <param name="suffix">The suffix.</param>
            <exception cref="T:System.ArgumentNullException">
            </exception>
        </member>
        <member name="P:Lime.Protocol.MediaType.Type">
            <summary>
            The top-level type identifier. The valid values are text, application, image, audio and video.
            </summary>
        </member>
        <member name="P:Lime.Protocol.MediaType.Subtype">
            <summary>
            The media type subtype.
            </summary>
        </member>
        <member name="P:Lime.Protocol.MediaType.Suffix">
            <summary>
            Media type suffix        
            </summary>
            <a href="http://tools.ietf.org/html/rfc6839"/>
        </member>
        <member name="P:Lime.Protocol.MediaType.IsJson">
            <summary>
            Indicates if the MIME represents a JSON type.
            </summary>
        </member>
        <member name="M:Lime.Protocol.MediaType.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <c cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.op_Equality(Lime.Protocol.MediaType,Lime.Protocol.MediaType)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.op_Inequality(Lime.Protocol.MediaType,Lime.Protocol.MediaType)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.op_Implicit(System.String)~Lime.Protocol.MediaType">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Lime.Protocol.MediaType" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.op_Implicit(Lime.Protocol.MediaType)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.MediaType"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="mediaType">Type of the media.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.MediaType.Parse(System.String)">
            <summary> 
            Parses the string to a MediaType object.
            </summary>
            <param name="s">The string.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">s</exception>
            <exception cref="T:System.FormatException">Invalid media type format</exception>
        </member>
        <member name="M:Lime.Protocol.MediaType.TryParse(System.String,Lime.Protocol.MediaType@)">
            <summary>
            Try parses the string to a MediaType object.
            </summary>
            <param name="s">The string.</param>
            <param name="mediaType">Type of the media.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Message">
            <summary>
            Provides the transport of a content between nodes in a network.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Message.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Message"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Message.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Message"/> class.
            </summary>
            <param name="id">The identifier.</param>
        </member>
        <member name="P:Lime.Protocol.Message.Type">
            <summary>
             MIME declaration of the content type of the message.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Message.Content">
            <summary>
            Message body content
            </summary>
        </member>
        <member name="M:Lime.Protocol.Message.Lime#Protocol#IDocumentContainer#GetDocument">
            <summary>
            Gets the contained document.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.CancellableTransportDecorator">
            <summary>
            Defines a decorator for <see cref="T:Lime.Protocol.Network.ITransport"/> that implements cancellation when it is not supported by the underlying instance.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ChannelBase">
            <summary>
            Base class for the protocol communication channels.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.#ctor(Lime.Protocol.Network.ITransport,System.TimeSpan,System.Nullable{System.TimeSpan},System.TimeSpan,System.Int32,System.Boolean,System.Boolean,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Creates a new instance of ChannelBase
            </summary>
            <param name="transport">The transport.</param>
            <param name="sendTimeout">The channel send timeout.</param>
            <param name="consumeTimeout">The channel consume timeout. Each envelope received from the transport must be consumed in the specified timeout or it will cause the channel to be closed.</param>
            <param name="closeTimeout">The channel close timeout.</param>
            <param name="envelopeBufferSize">Size of the envelope buffer.</param>
            <param name="fillEnvelopeRecipients">Indicates if the from and to properties of sent and received envelopes should be filled with the session information if not defined.</param>
            <param name="autoReplyPings">Indicates if the channel should reply automatically to ping request commands. In this case, the ping command are not returned by the ReceiveCommandAsync method.</param>
            <param name="remotePingInterval">The interval to ping the remote party.</param>
            <param name="remoteIdleTimeout">The timeout to close the channel due to inactivity.</param>
            <param name="channelCommandProcessor">The channel command processor.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">
            Invalid send timeout
            or
            Invalid consume timeout
            or
            Invalid close timeout
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.Transport">
            <summary>
            The current session transport
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.RemoteNode">
            <summary>
            Remote node identifier
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.LocalNode">
            <summary>
            Remote node identifier
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.SessionId">
            <summary>
            The session Id
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.State">
            <summary>
            Current session state
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.MessageModules">
            <inheritdoc />
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.NotificationModules">
            <inheritdoc />
        </member>
        <member name="P:Lime.Protocol.Network.ChannelBase.CommandModules">
            <inheritdoc />
        </member>
        <member name="E:Lime.Protocol.Network.ChannelBase.ConsumerException">
            <inheritdoc />
        </member>
        <member name="E:Lime.Protocol.Network.ChannelBase.SenderException">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.SendMessageAsync(Lime.Protocol.Message,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.ReceiveMessageAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.SendCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.ReceiveCommandAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.ProcessCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.SendNotificationAsync(Lime.Protocol.Notification,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.ReceiveNotificationAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.SendSessionAsync(Lime.Protocol.Session,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.ReceiveSessionAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.CloseTransportAsync">
            <summary>
            Closes the underlying transport.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.StopChannelTasks">
            <summary>
            Stops the sender and receiver tasks.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.Transport_Closing(System.Object,Lime.Protocol.Network.DeferralEventArgs)">
            <summary>
            Cancels the token that is associated to the channel send and receive tasks.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelBase.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:Lime.Protocol.Network.ChannelCommandProcessor">
            <summary>
            Utility class for handling the command processing workflow for channels.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.ICommandProcessor" />
        </member>
        <member name="T:Lime.Protocol.Network.ChannelExtensions">
            <summary>
            Utility extensions for the IChannel interface.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelExtensions.SendAsync``1(Lime.Protocol.Network.IEstablishedSenderChannel,``0)">
            <summary>
            Sends the envelope using the appropriate method for its type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="channel"></param>
            <param name="envelope"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelExtensions.SendAsync``1(Lime.Protocol.Network.IEstablishedSenderChannel,``0,System.Threading.CancellationToken)">
            <summary>
            Sends the envelope using the appropriate method for its type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="channel">The channel.</param>
            <param name="envelope">The envelope.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            </exception>
            <exception cref="T:System.ArgumentException">Invalid or unknown envelope type</exception>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelExtensions.IsActive(Lime.Protocol.Network.IChannel)">
            <summary>
            Indicates if the channel transport is connected and in a session negotiation/established state
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelExtensions.IsEstablished(Lime.Protocol.Network.IChannel)">
            <summary>
            Indicates if the channel transport is connected and in the <see cref="F:Lime.Protocol.SessionState.Established"/> state.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ChannelInformation">
            <summary>
            Provides information about a channel.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ChannelInformation.#ctor(System.String,Lime.Protocol.SessionState,Lime.Protocol.Node,Lime.Protocol.Node)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.ChannelInformation"/> class.
            </summary>
            <param name="sessionId">The session identifier.</param>
            <param name="state">The state.</param>
            <param name="localNode">The channel local node.</param>
            <param name="remoteNode">The channel remote node.</param>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelInformation.SessionId">
            <summary>
            Gets the associated channel session identifier.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelInformation.State">
            <summary>
            Gets the channel state.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelInformation.LocalNode">
            <summary>
            Gets the channel local node.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ChannelInformation.RemoteNode">
            <summary>
            Gets the channel remote node.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandOrThrowAsync(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.CommandMethod,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandOrThrowAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.CommandMethod,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandOrThrowAsync(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandWithResponseResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.CommandMethod,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status and returns the response resource.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandWithResponseResourceAsync``2(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.CommandMethod,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status and returns the response resource.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ProcessCommandWithResponseResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Processes a command throwing a <see cref="T:Lime.Protocol.Network.LimeException"/> in case of <see cref="F:Lime.Protocol.CommandStatus.Failure"/> status and returns the response resource.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.GetResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Gets a resource from the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.SetResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sets a the resource value in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.SetResourceAsync``2(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sets a the resource value in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.DeleteResourceAsync(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Delete a resource in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.DeleteResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Delete a resource in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.MergeResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Merges a the resource value in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.MergeResourceAsync``2(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Merges a the resource value in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.SubscribeResourceAsync(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Subscribe a resource in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.SubscribeResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Subscribe a resource in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.UnsubscribeResourceAsync(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Unsubscribe a resource in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.UnsubscribeResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Unsubscribe a resource in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ObserveResourceAsync``1(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Observes a the resource value in the specified URI.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.CommandProcessorExtensions.ObserveResourceAsync``2(Lime.Protocol.Network.ICommandProcessor,Lime.Protocol.LimeUri,``0,System.Threading.CancellationToken,Lime.Protocol.Node,Lime.Protocol.Node,Lime.Protocol.Node,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Observes a the resource value in the specified URI returning the response command resource value.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.DeferralEventArgs">
            <summary>
            Provides a command-style event, where the event generator will only continue the execution after the all the associated handlers finishes they execution.
            <a href="http://blog.stephencleary.com/2013/02/async-oop-5-events.html"/>
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.EnvelopeEventArgs`1">
            <summary>
            Holds the information for a envelope related event.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.EnvelopeEventArgs`1.Envelope">
            <summary>
            The envelope related to the event.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.EnvelopePipe">
            <summary>
            Manages <see cref="T:Lime.Protocol.Network.ITransport"/> buffers using the <see cref="T:System.IO.Pipelines.Pipe"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.#ctor(System.Func{System.Memory{System.Byte},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{System.Int32}},System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},Lime.Protocol.Serialization.IEnvelopeSerializer,Lime.Protocol.Network.ITraceWriter,System.Int32,System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Creates a new instance of <see cref="T:Lime.Protocol.Network.EnvelopePipe"/>.
            </summary>
            <param name="receiveFunc">The function that will be invoked by the receive task, which passes a memory to be filled by the underlying connection.</param>
            <param name="sendFunc">The function that will be invoked by the send task, container the buffer that should be written to the underlying connection.</param>
            <param name="envelopeSerializer">The envelope serializer</param>
            <param name="traceWriter">The trace writer</param>
            <param name="pauseWriterThreshold">The number of unconsumed bytes in the receive pipe to pause the read task.</param>
            <param name="memoryPool">The memory pool instance to be used by the pipes</param>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Starts the pipe producer / consumer tasks.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Stops the pipe producer / consumer tasks and awaits they to end.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.SendAsync(Lime.Protocol.Envelope,System.Threading.CancellationToken)">
            <summary>
            Writes a envelope into the send pipe.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>
            Receives an envelope from the receive pipe.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.ReceiveAndWriteToPipeAsync(System.Func{System.Memory{System.Byte},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{System.Int32}},System.IO.Pipelines.PipeWriter,System.Threading.CancellationToken)">
            <summary>
            Receives data from the provided function using the memory retrieve from the pipe writer.  
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.EnvelopePipe.ReadPipeAndSendAsync(System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.IO.Pipelines.PipeReader,System.Threading.CancellationToken)">
            <summary>
            Read data from the provided pipe and send it using the function. 
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ExceptionEventArgs">
            <summary>
            Provides informations about an event for an exception.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ExceptionEventArgs.Exception">
            <summary>
            Exception related to the event.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.FailedChannelInformation">
            <summary>
            Provides information about a failed channel.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.ChannelInformation" />
        </member>
        <member name="M:Lime.Protocol.Network.FailedChannelInformation.#ctor(System.String,Lime.Protocol.SessionState,Lime.Protocol.Node,Lime.Protocol.Node,System.Boolean,System.Exception,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.FailedChannelInformation"/> class.
            </summary>
            <param name="sessionId">The identifier.</param>
            <param name="state">The state.</param>
            <param name="isConnected">if set to <c>true</c> [is connected].</param>
            <param name="exception">The exception.</param>
            <param name="localNode"></param>
            <param name="remoteNode"></param>
            <param name="operationName"></param>
        </member>
        <member name="P:Lime.Protocol.Network.FailedChannelInformation.IsConnected">
            <summary>
            Gets a value indicating whether this instance is connected.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.FailedChannelInformation.Exception">
            <summary>
            Gets the exception that caused the channel to fail.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.FailedChannelInformation.OperationName">
            <summary>
            Gets the name of the operation that failed.
            </summary>       
        </member>
        <member name="T:Lime.Protocol.Network.IChannel">
            <summary>
            Defines a communication channel for the protocol.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.IEstablishedChannel" />
            <seealso cref="T:Lime.Protocol.Network.ISessionChannel" />
        </member>
        <member name="P:Lime.Protocol.Network.IChannel.Transport">
            <summary>
            Gets the current session transport.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannel.MessageModules">
            <summary>
            Gets the message modules for processing sent and received messages.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannel.NotificationModules">
            <summary>
            Gets the notification modules for processing sent and received notifications.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannel.CommandModules">
            <summary>
            Gets the command modules for processing sent and received commands.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Network.IChannel.ConsumerException">
            <summary>
            Occurs when the channel consumer task throws an exception.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Network.IChannel.SenderException">
            <summary>
            Occurs when the channel sender task throws an exception.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IChannelCommandProcessor">
            <summary>
            Defines the workflow for synchronous command processing.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.ICommandProcessor" />
        </member>
        <member name="M:Lime.Protocol.Network.IChannelCommandProcessor.ProcessCommandAsync(Lime.Protocol.Network.ICommandSenderChannel,Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Processes the command asynchronous.
            </summary>
            <param name="commandSenderChannel">The command sender channel.</param>
            <param name="requestCommand">The request command.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.IChannelCommandProcessor.TrySubmitCommandResult(Lime.Protocol.Command)">
            <summary>
            Try to submit a command as a result for a pending command request.
            </summary>
            <param name="responseCommand">The response command.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.IChannelCommandProcessor.CancelAll">
            <summary>
            Cancels all pending command requests.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IChannelInformation">
            <summary>
            Provides information about a channel.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannelInformation.SessionId">
            <summary>
            Gets the channel session identifier.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannelInformation.State">
            <summary>
            Gets the channel state.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannelInformation.LocalNode">
            <summary>
            Gets the channel local node.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.IChannelInformation.RemoteNode">
            <summary>
            Gets the channel remote node.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IChannelModule`1">
            <summary>
            Defines a proxy interface for executing actions to the envelope channels.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lime.Protocol.Network.IChannelModule`1.OnStateChanged(Lime.Protocol.SessionState)">
            <summary>
            Called when the session state is changed.
            </summary>
            <param name="state">The state.</param>
        </member>
        <member name="M:Lime.Protocol.Network.IChannelModule`1.OnReceivingAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Called when an envelope is being received by the channel.
            </summary>
            <param name="envelope">The envelope.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The received envelope. If the value is null, the received envelope will be ignored.</returns>
        </member>
        <member name="M:Lime.Protocol.Network.IChannelModule`1.OnSendingAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Called when an envelope is being sent by the channel.
            </summary>
            <param name="envelope">The envelope.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The envelope to be sent. If the value is null, the sent envelope will be ignored.</returns>
        </member>
        <member name="T:Lime.Protocol.Network.ICommandChannel">
            <summary>
            Defines a channel to exchange command envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ICommandSenderChannel">
            <summary>
            Defines a channel to send command envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ICommandSenderChannel.SendCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Sends a command to the remote node.
            </summary>
            <param name="command"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.ICommandReceiverChannel">
            <summary>
            Defines a channel to receive command envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ICommandReceiverChannel.ReceiveCommandAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a command from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.ICommandProcessor">
            <summary>
            Defines a command processor, that allows sending a command request and awaits for a response.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ICommandProcessor.ProcessCommandAsync(Lime.Protocol.Command,System.Threading.CancellationToken)">
            <summary>
            Processes a command request, awaiting for the response.
            </summary>
            <param name="requestCommand">The command request.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.CommandSenderChannelExtensions.SendCommandAsync(Lime.Protocol.Network.ICommandSenderChannel,Lime.Protocol.Command)">
            <summary>
            Sends a command to the remote node.
            </summary>
            <param name="channel"></param>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.IEstablishedChannel">
            <summary>
            Defines a channel to exchange envelopes in an established session.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IEstablishedReceiverChannel">
            <summary>
            Defines a channel to receive envelopes in an established session.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IEstablishedSenderChannel">
            <summary>
            Defines a channel to send envelopes in an established session.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IMessageChannel">
            <summary>
            Defines a channel to exchange message envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.IMessageSenderChannel">
            <summary>
            Defines a channel to send message envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.IMessageSenderChannel.SendMessageAsync(Lime.Protocol.Message,System.Threading.CancellationToken)">
            <summary>
            Sends a message to the remote node.
            </summary>
            <param name="message"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.IMessageReceiverChannel">
            <summary>
            Defines a channel to receive message envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.IMessageReceiverChannel.ReceiveMessageAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a message from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.MessageSenderChannelExtensions.SendMessageAsync(Lime.Protocol.Network.IMessageSenderChannel,Lime.Protocol.Message)">
            <summary>
            Sends a message to the remote node.
            </summary>
            <param name="channel"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.INotificationChannel">
            <summary>
            Defines a channel to exchange notification envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.INotificationSenderChannel">
            <summary>
            Defines a channel to send notification envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.INotificationSenderChannel.SendNotificationAsync(Lime.Protocol.Notification,System.Threading.CancellationToken)">
            <summary>
            Sends a notification to the remote node.
            </summary>
            <param name="notification"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.INotificationReceiverChannel">
            <summary>
            Defines a channel to receive notification envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.INotificationReceiverChannel.ReceiveNotificationAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a notification from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.NotificationSenderChannelExtensions.SendNotificationAsync(Lime.Protocol.Network.INotificationSenderChannel,Lime.Protocol.Notification)">
            <summary>
            Sends a notification to the remote node.
            </summary>
            <param name="channel"></param>
            <param name="notification"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.IReceiverChannel">
            <summary>
            Defines a channel to receive envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ISenderChannel">
            <summary>
            Defines a channel to send envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ISessionChannel">
            <summary>
            Defines a channel to exchange session envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ISessionSenderChannel">
            <summary>
            Defines a channel to send session envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ISessionSenderChannel.SendSessionAsync(Lime.Protocol.Session,System.Threading.CancellationToken)">
            <summary>
            Sends a session to the remote node.
            </summary>
            <param name="session"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.ISessionReceiverChannel">
            <summary>
            Defines a channel to receive session envelopes.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ISessionReceiverChannel.ReceiveSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a session from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.ITraceWriter">
            <summary>
            Enable request tracing
            for network transports
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ITraceWriter.TraceAsync(System.String,Lime.Protocol.Network.DataOperation)">
            <summary>
            Writes the provided data into the tracing output.
            </summary>
            <param name="data"></param>
            <param name="operation"></param>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Network.ITraceWriter.IsEnabled">
            <summary>
            Indicates if the tracer is enabled.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.DataOperation">
            <summary>
            Represents the transport operations.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Network.DataOperation.Send">
            <summary>
            A transport send operation
            </summary>
        </member>
        <member name="F:Lime.Protocol.Network.DataOperation.Receive">
            <summary>
            A transport receive operation
            </summary>
        </member>
        <member name="F:Lime.Protocol.Network.DataOperation.Error">
            <summary>
            A transport failure
            </summary>
        </member>
        <member name="F:Lime.Protocol.Network.DataOperation.Information">
            <summary>
            A transport information
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ITransport">
            <summary>
            Defines a network connection with a node.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.SendAsync(Lime.Protocol.Envelope,System.Threading.CancellationToken)">
            <summary>
            Sends an envelope to the remote node.
            </summary>
            <param name="envelope">Envelope to be transported</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>
            Receives an envelope from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.OpenAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Opens the transport connection with the specified Uri.
            </summary>
            <param name="uri"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.CloseAsync(System.Threading.CancellationToken)">
            <summary>
            Closes the connection
            <param name="cancellationToken">The cancellation token.</param>
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.GetSupportedCompression">
            <summary>
            Enumerates the supported compression options for the transport.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.SetCompressionAsync(Lime.Protocol.SessionCompression,System.Threading.CancellationToken)">
            <summary>
            Defines the compression mode for the transport.
            </summary>
            <param name="compression">The compression mode</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.GetSupportedEncryption">
            <summary>
            Enumerates the supported encryption options for the transport.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.SetEncryptionAsync(Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Defines the encryption mode for the transport.
            </summary>
            <param name="encryption">The encryption mode</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.ITransport.SetOptionAsync(System.String,System.Object)">
            <summary>
            Sets a transport option value.
            </summary>
            <param name="name">Name of the option.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="E:Lime.Protocol.Network.ITransport.Closing">
            <summary>
            Occurs when the transport is about to be closed.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Network.ITransport.Closed">
            <summary>
            Occurs after the transport was closed.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.ITransportInformation">
            <summary>
            Provides information about a transport connection.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.Compression">
            <summary>
            Gets the current transport compression option.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.Encryption">
            <summary>
            Gets the current transport encryption option.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.IsConnected">
            <summary>
            Indicates if the transport is connected.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.LocalEndPoint">
            <summary>
            Gets the local endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.RemoteEndPoint">
            <summary>
            Gets the remote endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.ITransportInformation.Options">
            <summary>
            Gets specific transport options informations.
            </summary>        
        </member>
        <member name="T:Lime.Protocol.Network.JsonBuffer">
            <summary>
            Provides a buffer with a method for JSON extraction.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.JsonBuffer.#ctor(System.Int32,System.Int32,System.Buffers.ArrayPool{System.Byte})">
            <summary>
            Creates a new instance of <see cref="T:Lime.Protocol.Network.JsonBuffer"/> class.
            </summary>
            <param name="bufferSize">The default buffer size.</param>
            <param name="maxBufferSize">The max buffer size for increasing.</param>
            <param name="arrayPool">The array pool for getting buffer instances.</param>
        </member>
        <member name="M:Lime.Protocol.Network.JsonBuffer.TryExtractJsonFromBuffer(System.Byte[]@)">
            <summary>
            Try to extract a JSON document from the buffer, based on the brackets count.
            </summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.JsonBuffer.IncreaseBuffer">
            <summary>
            Increases the receiver buffer, if allowed.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.JsonBuffer.TryExtractJsonFromBuffer(System.Buffers.ReadOnlySequence{System.Byte},System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Try to extract a JSON document from the buffer, based on the brackets count.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.LimeException">
            <summary>
            Represents protocol errors ocurred 
            during the communication
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.LimeException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.LimeException"/> class.
            </summary>
            <param name="reasonCode">The reason code.</param>
            <param name="reasonDescription">The reason description.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Lime.Protocol.Network.LimeException.#ctor(Lime.Protocol.Reason,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.LimeException"/> class.
            </summary>
            <param name="reason">The reason.</param>
            <param name="innerException">The inner exception.</param>
            <exception cref="T:System.ArgumentNullException">reason</exception>
        </member>
        <member name="P:Lime.Protocol.Network.LimeException.Reason">
            <summary>
            Associated reason 
            for the failure
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.ExtractContainerMessageModule">
            <summary>
            Extract the value of container documents directly to the message.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.Modules.ChannelModuleBase`1" />
        </member>
        <member name="T:Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule`1">
            <summary>
            Defines a channel module that fills envelope receipts based on the channel information.
            </summary>
            <typeparam name="T"></typeparam>
            <seealso cref="T:Lime.Protocol.Network.Modules.ChannelModuleBase`1" />
        </member>
        <member name="T:Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule">
            <summary>
            Wrapper class for <see cref="T:Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule`1"/> instances.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.Modules.ChannelModuleBase`1" />
        </member>
        <member name="M:Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule.CreateAndRegister(Lime.Protocol.Network.IChannel)">
            <summary>
            Creates a new instance of<see cref= "T:Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule" /> class and register it for all envelope types into the specified channel.
            </summary>
            <param name="channel">The channel.</param>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.NotifyReceiptChannelModule">
            <summary>
            Defines a channel module that automatically send a <see cref="T:Lime.Protocol.Notification"/> for each received message.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.RemotePingChannelModule">
            <summary>
            Defines a module that pings the remote party after a period of inactivity.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.RemotePingChannelModule.#ctor(Lime.Protocol.Network.IChannel,System.TimeSpan,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.Modules.RemotePingChannelModule"/> class.
            </summary>
            <param name="channel">The channel.</param>
            <param name="remotePingInterval">The remote ping interval.</param>
            <param name="remoteIdleTimeout">The remote idle timeout.</param>
            <param name="finishChannelTimeout">The finish channel timeout.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.RemotePingChannelModule.CreateAndRegister(Lime.Protocol.Network.IChannel,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a new instance of <see cref="T:Lime.Protocol.Network.Modules.RemotePingChannelModule"/> class and register it to the specified channel.
            </summary>
            <param name="channel">The channel.</param>
            <param name="remotePingInterval">The remote ping interval.</param>
            <param name="remoteIdleTimeout">The remote idle timeout.</param>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.ReplyPingChannelModule">
            <summary>
            Defines a channel module that automatically replies to ping request commands.
            </summary>
            <seealso cref="!:ChannelModuleBase&lt;T&gt;.Protocol.Command&gt;" />
        </member>
        <member name="T:Lime.Protocol.Network.Modules.Resend.IDeadMessageHandler">
            <summary>
            Defines a service for handling dead messages (messages without notification after retries) for the <see cref="T:Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IDeadMessageHandler.HandleDeadMessageAsync(Lime.Protocol.Message,Lime.Protocol.Network.IChannelInformation,System.Threading.CancellationToken)">
            <summary>
            Handles a channel dead message.
            </summary>
            <param name="message"></param>
            <param name="channelInformation"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.Resend.IKeyProvider">
            <summary>
            Create the keys to be used by the <see cref="T:Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule"/> module.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IKeyProvider.GetChannelKey(Lime.Protocol.Network.IChannel)">
            <summary>
            Gets a key for the specified channel.
            </summary>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IKeyProvider.GetMessageKey(Lime.Protocol.Message,Lime.Protocol.Network.IChannel)">
            <summary>
            Gets a key for the specified message.
            </summary>
            <param name="message"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IKeyProvider.GetMessageKey(Lime.Protocol.Notification,Lime.Protocol.Network.IChannel)">
            <summary>
            Gets a message key for the specified notification.
            </summary>
            <param name="notification"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.Resend.IMessageStorage">
            <summary>
            Defines a service for storing messages for the <see cref="T:Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule"/> module.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IMessageStorage.AddAsync(System.String,System.String,Lime.Protocol.Message,System.DateTimeOffset,System.Threading.CancellationToken)">
            <summary>
            Stores a message for further retrying.
            </summary>
            <param name="channelKey"></param>
            <param name="messageKey"></param>
            <param name="message"></param>
            <param name="resendAt"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IMessageStorage.RemoveAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Removes a stored retry message, returning the removed value if available.
            </summary>
            <param name="channelKey"></param>
            <param name="messageKey"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.IMessageStorage.GetMessagesToResendKeysAsync(System.String,System.DateTimeOffset,System.Threading.CancellationToken)">
            <summary>
            Gets the keys of the messages that should be resent given the specified reference date.
            </summary>
            <param name="channelKey"></param>
            <param name="reference"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.Resend.MemoryMessageStorage">
            <inheritdoc />
            <summary>
            Represents a memory message storage for resending messages.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.MemoryMessageStorage.#ctor(System.TimeSpan,System.Int32)">
            <summary>
            Initialize a new instance of <see cref="T:Lime.Protocol.Network.Modules.Resend.MemoryMessageStorage"/>.
            </summary>
            <param name="resendExpiration">The interval to remove messages to resend for storage.</param>
            <param name="checkForRemovalInterval">The interval for checking for messages to removal.</param>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule.RegisterTo(Lime.Protocol.Network.IChannel)">
            <summary>
            RegisterDocument the module to the specified channel.
            </summary>
            <param name="channel"></param>
        </member>
        <member name="T:Lime.Protocol.Network.Modules.ThroughputControlChannelModule">
            <summary>
            Defines a channel module that controls envelope throughput
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.Modules.ThroughputControlChannelModule.CreateAndRegister(Lime.Protocol.Network.IChannel,System.Int32)">
            <summary>
            Creates a new instance of<see cref= "T:Lime.Protocol.Network.Modules.ThroughputControlChannelModule" /> class and register it for all envelope types into the specified channel.
            </summary>
            <param name="channel">The channel.</param>
            <param name="throughput">Number of allowed envelopes per second</param>
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.ReceiveMessageAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.ReceiveCommandAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.ReceiveNotificationAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.ReceiveSessionAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.ReceiveFromBufferAsync``1(System.Threading.Channels.ChannelReader{``0},System.Collections.Generic.IEnumerable{Lime.Protocol.Network.IChannelModule{``0}},System.Threading.CancellationToken)">
            <summary>
            Receives an envelope from the buffer.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.ReceiverChannel.RaiseReceiverException(System.Exception)">
            <summary>
            Asynchronously raises the channel exception to avoid deadlocks issues.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.SenderChannel.SendToBufferAsync``1(``0,System.Collections.Generic.IEnumerable{Lime.Protocol.Network.IChannelModule{``0}},System.Threading.CancellationToken)">
            <summary>
            Sends the envelope to the specified target.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.SenderChannel.RaiseSenderException(System.Exception)">
            <summary>
            Asynchronously raises the channel exception to avoid deadlocks issues.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.SynchronizedTransportDecorator">
            <summary>
            Defines a decorator for <see cref="T:Lime.Protocol.Network.ITransport"/> that synchronizes concurrent <see cref="M:Lime.Protocol.Network.SynchronizedTransportDecorator.SendAsync(Lime.Protocol.Envelope,System.Threading.CancellationToken)"/> and <see cref="M:Lime.Protocol.Network.SynchronizedTransportDecorator.ReceiveAsync(System.Threading.CancellationToken)"/> calls.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.TraceWriter">
            <summary>
            Traces into the default .NET tracers.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.TransportBase">
            <summary>
            Base class for transport implementation.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.SendAsync(Lime.Protocol.Envelope,System.Threading.CancellationToken)">
            <summary>
            Sends an envelope to the connected node.
            </summary>
            <param name="envelope">Envelope to be transported</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>
            Receives an envelope from the remote node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.OpenAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Opens the transport connection with the specified Uri.
            </summary>
            <param name="uri"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.CloseAsync(System.Threading.CancellationToken)">
            <summary>
            Closes the connection
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.GetSupportedCompression">
            <summary>
            Enumerates the supported compression options for the transport.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.Compression">
            <summary>
            Gets the current transport 
            compression option
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.SetCompressionAsync(Lime.Protocol.SessionCompression,System.Threading.CancellationToken)">
            <summary>
            Defines the compression mode for the transport.
            </summary>
            <param name="compression">The compression mode</param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.GetSupportedEncryption">
            <summary>
            Enumerates the supported encryption options for the transport.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.Encryption">
            <summary>
            Gets the current transport encryption option.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.IsConnected">
            <summary>
            Indicates if the transport is connected.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.LocalEndPoint">
            <summary>
            Gets the local endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.RemoteEndPoint">
            <summary>
            Gets the remote endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportBase.Options">
            <summary>
            Gets specific transport metadata information.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.SetEncryptionAsync(Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Defines the encryption mode for the transport.
            </summary>
            <param name="encryption"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.SetOptionAsync(System.String,System.Object)">
            <summary>
            Sets a transport option value.
            </summary>
            <param name="name">Name of the option.</param>
            <param name="value">The value.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="E:Lime.Protocol.Network.TransportBase.Closing">
            <summary>
            Occurs when the channel is about to be closed.
            </summary>
        </member>
        <member name="E:Lime.Protocol.Network.TransportBase.Closed">
            <summary>
            Occurs after the connection was closed.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.PerformCloseAsync(System.Threading.CancellationToken)">
            <summary>
            Closes the transport.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.PerformOpenAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Opens the transport connection with the specified Uri.
            </summary>
            <param name="uri"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.OnClosingAsync">
            <summary>
            Raises the Closing event with a deferral to wait the event handlers to complete the execution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Network.TransportBase.OnClosed">
            <summary>
            Raises the Closed event.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Network.TransportInformation">
            <summary>
            Provides information about a transport connection.
            </summary>
            <seealso cref="T:Lime.Protocol.Network.ITransportInformation" />
        </member>
        <member name="M:Lime.Protocol.Network.TransportInformation.#ctor(Lime.Protocol.SessionCompression,Lime.Protocol.SessionEncryption,System.Boolean,System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Network.TransportInformation"/> class.
            </summary>
            <param name="compression">The compression.</param>
            <param name="encryption">The encryption.</param>
            <param name="isConnected">if set to <c>true</c> [is connected].</param>
            <param name="localEndPoint">The local end point.</param>
            <param name="remoteEndPoint">The remote end point.</param>
            <param name="options">The options.</param>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.Compression">
            <summary>
            Gets the current transport compression option.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.Encryption">
            <summary>
            Gets the current transport encryption option.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.IsConnected">
            <summary>
            Indicates if the transport is connected.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.LocalEndPoint">
            <summary>
            Gets the local endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.RemoteEndPoint">
            <summary>
            Gets the remote endpoint address.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Network.TransportInformation.Options">
            <summary>
            Gets specific transport options informations.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Network.X509CertificateExtensions.GetDomainRole(System.Security.Cryptography.X509Certificates.X509Certificate2,Lime.Protocol.Identity)">
            <summary>
            Gets the identity domain role for the given certificate.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Node">
            <summary>
            Represents an element of a network.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Node.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Node"/> class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Node.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Node"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="domain">The domain.</param>
            <param name="instance">The instance.</param>
        </member>
        <member name="P:Lime.Protocol.Node.Instance">
            <summary>
            The name of the instance used by the node to connect to the network.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Node.ToString">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Node.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Node.op_Equality(Lime.Protocol.Node,Lime.Protocol.Node)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.op_Inequality(Lime.Protocol.Node,Lime.Protocol.Node)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.op_Implicit(System.String)~Lime.Protocol.Node">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Node"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lime.Protocol.Node"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.op_Implicit(Lime.Protocol.Node)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.Node"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="node">The node.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.Parse(System.String)">
            <summary>
            Parses the string to a valid Node.
            </summary>
            <param name="s">The s.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">s</exception>
            <exception cref="T:System.FormatException">Invalid Peer format</exception>
        </member>
        <member name="M:Lime.Protocol.Node.TryParse(System.String,Lime.Protocol.Node@)">
            <summary>
            Tries to parse the string to a valid Node
            </summary>
            <param name="s">The s.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Node.ToIdentity">
            <summary>
            Creates an Identity instance based on the Node identity.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lime.Protocol.Node.IsComplete">
            <summary>
            Indicates if the node is a complete representation, 
            with name, domain and instance.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Node.Copy">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Node.ToImmutableNode">
            <summary>
            Create a new instance of <see cref="T:Lime.Protocol.Immutable.Node"/> which is immutable based on this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.NodeDocument">
            <summary>
            Represents a node document.
            </summary>
        </member>
        <member name="P:Lime.Protocol.NodeDocument.Value">
            <summary>
            The value of the document
            </summary>
        </member>
        <member name="M:Lime.Protocol.NodeDocument.Parse(System.String)">
            <summary>
            Parses the string to a 
            IdentityDocument instance.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Notification">
            <summary>
            Transports information about events associated to a message in a session. 
            Can be originated by a server or by the message destination node.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Notification.Event">
            <summary>
            Related event to the notification
            </summary>
        </member>
        <member name="P:Lime.Protocol.Notification.Reason">
            <summary>
            In the case of a failed event, 
            brings more details about 
            the problem.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Event">
            <summary>
            Events that can happen in the message pipeline.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Failed">
            <summary>
            A problem occurred during the processing of the message. 
            In this case, the reason  property of the notification SHOULD be present.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Accepted">
            <summary>
            The message was received and accepted by the server.
            This event is similar to the <see cref="F:Lime.Protocol.Event.Received"/> but is emitted by an intermediate node (hop) and not by the message's final destination.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Validated">
            <summary>
            The message format was validated by the server.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Authorized">
            <summary>
            The dispatch of the message was authorized by the server.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Dispatched">
            <summary>
            The message was dispatched to the destination by the server.
            This event is similar to the <see cref="F:Lime.Protocol.Event.Consumed"/> but is emitted by an intermediate node (hop) and not by the message's final destination.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Received">
            <summary>
            The node has received the message.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Event.Consumed">
            <summary>
            The node has consumed the content of the message.
            </summary>
        </member>
        <member name="T:Lime.Protocol.PlainDocument">
            <summary>
            Represents a plain document.
            </summary>
        </member>
        <member name="M:Lime.Protocol.PlainDocument.#ctor(Lime.Protocol.MediaType)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.PlainDocument"/> class.
            </summary>
            <param name="mediaType">Type of the media.</param>
        </member>
        <member name="M:Lime.Protocol.PlainDocument.#ctor(System.String,Lime.Protocol.MediaType)">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.PlainDocument"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="mediaType">Type of the media.</param>
            <exception cref="T:System.ArgumentException">Invalid media type. The suffix value should be empty.</exception>
        </member>
        <member name="P:Lime.Protocol.PlainDocument.Value">
            <summary>
            The value of the document.
            </summary>
        </member>
        <member name="M:Lime.Protocol.PlainDocument.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Lime.Protocol.PlainDocument.op_Implicit(Lime.Protocol.PlainDocument)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Lime.Protocol.PlainDocument" /> to <see cref="T:System.String" />.
            </summary>
            <param name="plainDocument">The plain document.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="T:Lime.Protocol.Reason">
            <summary>
            Represents a known reason for
            events occurred during the client-server 
            interactions.
            </summary>
        </member>
        <member name="T:Lime.Protocol.ReasonCodes">
            <summary>
            Default server reason codes
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GENERAL_ERROR">
            <summary>
            General error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_ERROR">
            <summary>
            General session error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_REGISTRATION_ERROR">
            <summary>
            The session resource is already registered
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_AUTHENTICATION_FAILED">
            <summary>
            An authentication error occurred
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_UNREGISTER_FAILED">
            <summary>
            An error occurred while unregistering the session 
            in the server
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_INVALID_ACTION_FOR_STATE">
            <summary>
            The required action is invalid for
            current session state
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_NEGOTIATION_TIMEOUT">
            <summary>
            The session negotiation has timed out
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_NEGOTIATION_INVALID_OPTIONS">
            <summary>
            Invalid selected negotiation options
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.SESSION_INVALID_SESSION_MODE_REQUESTED">
            <summary>
            Invalid session mode requested
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_ERROR">
            <summary>
            General validation error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_EMPTY_DOCUMENT">
            <summary>
            The envelope document is null
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_RESOURCE">
            <summary>
            The envelope document MIME type is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_STATUS">
            <summary>
            The request status is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_IDENTITY">
            <summary>
            The request identity is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_RECIPIENTS">
            <summary>
            The envelope originator or destination is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_METHOD">
            <summary>
            The command method is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.VALIDATION_INVALID_URI">
            <summary>
            The command URI format is invalid
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.AUTHORIZATION_ERROR">
            <summary>
            General authorization error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.AUTHORIZATION_UNAUTHORIZED_SENDER">
            <summary>
            The sender is not authorized to send
            messages to the message destination
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.AUTHORIZATION_DESTINATION_ACCOUNT_NOT_FOUND">
            <summary>
            The destination doesn't have an active 
            account
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.AUTHORIZATION_QUOTA_THRESHOLD_EXCEEDED">
            <summary>
            The envelope quota limit has been exceeded
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.AUTHORIZATION_PERMISSION_REQUIRED">
            <summary>
            The sender does not have the required permission
            to execute the operation
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.ROUTING_ERROR">
            <summary>
            General routing error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.ROUTING_DESTINATION_NOT_FOUND">
            <summary>
            The message destination was not found
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.ROUTING_GATEWAY_NOT_FOUND">
            <summary>
            The message destination gateway was not found
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.ROUTING_ROUTE_NOT_FOUND">
            <summary>
            The message destination was not found
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.DISPATCH_ERROR">
            <summary>
            General dispatching error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_PROCESSING_ERROR">
            <summary>
            General command processing error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_RESOURCE_NOT_SUPPORTED">
            <summary>
            There's no command processor available 
            for process the request
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_METHOD_NOT_SUPPORTED">
            <summary>
            The command method is not supported
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_INVALID_ARGUMENT">
            <summary>
            The command method has an invalid argument value
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_INVALID_SESSION_MODE">
            <summary>
            The requested command is not valid for current
            session mode
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_NOT_ALLOWED">
            <summary>
            The command method was not allowed
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.COMMAND_RESOURCE_NOT_FOUND">
            <summary>
            The command resource was not found
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.MESSAGE_PROCESSING_ERROR">
            <summary>
            General message processing error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.MESSAGE_UNSUPPORTED_CONTENT_TYPE">
            <summary>
            The message content type
            is not supported
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_ERROR">
            <summary>
            General gateway processing error
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_CONTENT_TYPE_NOT_SUPPORTED">
            <summary>
            The content type is not supported
            by the gateway
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_DESTINATION_NOT_FOUND">
            <summary>
            The message destination was not found
            on gateway
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_NOT_SUPPORTED">
            <summary>
            The functionality is not supported 
            by the gateway
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_REQUEST_LIMIT_REACHED">
            <summary>
            The request limit has been reached
            by the gateway
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_OPERATION_TIMED_OUT">
            <summary>
            The gateway operation timed out
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.GATEWAY_UNAUTHORIZED_SENDER">
            <summary>
            The destination on the Gateway end has blocked the originator
            </summary>
        </member>
        <member name="F:Lime.Protocol.ReasonCodes.APPLICATION_ERROR">
            <summary>
            General application processing error
            </summary>
        </member>
        <member name="T:Lime.Protocol.Security.Authentication">
            <summary>
            Base class for the supported 
            authentication schemes
            </summary>
        </member>
        <member name="T:Lime.Protocol.Security.AuthenticationScheme">
            <summary>
            Defines the valid authentication schemes values.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.AuthenticationScheme.Guest">
            <summary>
            The server doesn't requires a client credential, and provides a temporary identity to the node. 
            Some restriction may apply to guest sessions,  like the inability of sending some commands or other nodes may want to block messages originated by guest identities.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.AuthenticationScheme.Plain">
            <summary>
            Username and password authentication.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.AuthenticationScheme.Transport">
            <summary>
            Transport layer authentication.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.AuthenticationScheme.Key">
            <summary>
            Key authentication.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.AuthenticationScheme.External">
            <summary>
            Third-party authentication.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Security.ExternalAuthentication">
            <summary>
            Defines a external authentication scheme, that uses third-party validation.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Security.ExternalAuthentication.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Security.ExternalAuthentication"/> class.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Security.ExternalAuthentication.Token">
            <summary>
            Gets or sets the authentication token on base64 representation.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Security.ExternalAuthentication.Issuer">
            <summary>
            Gets or sets the trusted token issuer.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Security.ExternalAuthentication.SetToBase64Token(System.String)">
            <summary>
            Set a plain token to a base64 representation
            </summary>
            <param name="password"></param>
        </member>
        <member name="M:Lime.Protocol.Security.ExternalAuthentication.GetFromBase64Token">
            <summary>
            Gets the token decoded from the Base64 representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Security.GuestAuthentication">
            <summary>
            Defines a guest authentication scheme
            </summary>
        </member>
        <member name="T:Lime.Protocol.Security.IAuthenticatableTransport">
            <summary>
            Defines a transport that supports authentication.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Security.IAuthenticatableTransport.AuthenticateAsync(Lime.Protocol.Identity)">
            <summary>
            Authenticate the identity in the transport layer.
            </summary>
            <param name="identity">The identity to be authenticated</param>
            <returns>Indicates if the identity is authenticated</returns>
        </member>
        <member name="T:Lime.Protocol.Security.DomainRole">
            <summary>
            Indicates the role of an identity in a domain.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.DomainRole.Unknown">
            <summary>
            The identity is unknown in the domain.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.DomainRole.Member">
            <summary>
            The identity is a member of the domain.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.DomainRole.Authority">
            <summary>
            The identity is an authority of the domain.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Security.DomainRole.RootAuthority">
            <summary>
            The identity is an authority of the domain and its sub-domains.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Security.KeyAuthentication">
            <summary>
            Defines a authentication scheme that uses a key for authentication.
            Should be used only with encrypted sessions.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Security.KeyAuthentication.Key">
            <summary>
            Base64 representation of the identity key.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Security.KeyAuthentication.SetToBase64Key(System.String)">
            <summary>
            Set a plain key to a Base64 representation.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Lime.Protocol.Security.KeyAuthentication.GetFromBase64Key">
            <summary>
            Gets the plain key decoded from the Base64 representation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Security.PlainAuthentication">
            <summary>
            Defines a plain authentication scheme, that uses a password for authentication.
            Should be used only with encrypted sessions.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Security.PlainAuthentication.Password">
            <summary>
            Base64 representation of the 
            identity password
            </summary>
        </member>
        <member name="M:Lime.Protocol.Security.PlainAuthentication.SetToBase64Password(System.String)">
            <summary>
            Set a plain password to a 
            Base64 representation
            </summary>
            <param name="password"></param>
        </member>
        <member name="M:Lime.Protocol.Security.PlainAuthentication.GetFromBase64Password">
            <summary>
            Gets the plain password decoded 
            from the Base64 representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Security.TransportAuthentication">
            <summary>
            Defines a transport layer authentication scheme. 
            </summary>
        </member>
        <member name="P:Lime.Protocol.Security.TransportAuthentication.DomainRole">
            <summary>
            The domain role determined by the <see cref="M:Lime.Protocol.Security.IAuthenticatableTransport.AuthenticateAsync(Lime.Protocol.Identity)"/> method call.
            This value should not be serialized.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.DictionaryExtensions.RemoveAndAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Removes the element with the specified key from the dictionary and  adds an element with the provided key and value.
            Note: This call is not synchronized.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:Lime.Protocol.Serialization.DocumentTypeResolver">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Serialization.DocumentTypeResolver.RegisterDocument(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Lime.Protocol.Serialization.DocumentTypeResolver.TryGetTypeForMediaType(Lime.Protocol.MediaType,System.Type@)">
            <inheritdoc />
        </member>
        <member name="T:Lime.Protocol.Serialization.IDocumentTypeResolver">
            <summary>
            Defines a service for mapping MIME media types to .NET document types.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.IDocumentTypeResolver.RegisterDocument(System.Type)">
            <summary>
            RegisterDocument the specified document type.
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Lime.Protocol.Serialization.IDocumentTypeResolver.TryGetTypeForMediaType(Lime.Protocol.MediaType,System.Type@)">
            <summary>
            Try determine a document type for a media type.
            </summary>
            <param name="mediaType"></param>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.DocumentTypeResolverExtensions.RegisterDocument``1(Lime.Protocol.Serialization.IDocumentTypeResolver)">
            <summary>
            RegisterDocument the specified document type.
            </summary>
            <typeparam name="TDocument"></typeparam>
            <param name="typeResolver"></param>
        </member>
        <member name="M:Lime.Protocol.Serialization.DocumentTypeResolverExtensions.RegisterAssemblyDocuments(Lime.Protocol.Serialization.IDocumentTypeResolver,System.Reflection.Assembly)">
            <summary>
            RegisterDocument all documents in the specified assembly.
            </summary>
            <param name="typeResolver"></param>
            <param name="assembly"></param>
        </member>
        <member name="T:Lime.Protocol.Serialization.IEnvelopeSerializer">
            <summary>
            Base interface for envelope serializers.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.IEnvelopeSerializer.Serialize(Lime.Protocol.Envelope)">
            <summary>
            Serialize an envelope to a string.
            </summary>
            <param name="envelope"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.IEnvelopeSerializer.Deserialize(System.String)">
            <summary>
            Deserialize an envelope from a string.
            </summary>
            <param name="envelopeString"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.Newtonsoft.Converters.SessionJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name = "reader">The <see cref = "T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name = "objectType">Type of the object.</param>
            <param name = "existingValue">The existing value of object being read.</param>
            <param name = "serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="T:Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer">
            <summary>
            Serializes using the Newtonsoft.Json library.
            </summary>
            <seealso cref="T:Lime.Protocol.Serialization.IEnvelopeSerializer" />
        </member>
        <member name="P:Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer.Serializer">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.JsonSerializer"/> used for serialization and deserialization of envelopes.
            This property is lazy. The construction of the <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance will only
            happen after the first invocation of the <see langword="get"/> accessor.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer.Serialize(Lime.Protocol.Envelope)">
            <summary>
            Serialize an envelope to a string.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer.Deserialize(System.String)">
            <summary>
            Deserialize an envelope from a string.
            </summary>
            <exception cref = "T:System.ArgumentException">JSON string is not a valid envelope</exception>
        </member>
        <member name="M:Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer.TryAddConverter(Newtonsoft.Json.JsonConverter,System.Boolean)">
            <summary>
            Adds the provided <paramref name="jsonConverter"/> to the list of converters used by the underlying serializer.
            </summary>
            <param name="jsonConverter">The <see cref="T:Newtonsoft.Json.JsonConverter"/> to be added.</param>
            <param name="ignoreDuplicates">Whether the provided <paramref name="jsonConverter"/> should be added when there is already one instance of that converter type.</param>
            <returns><see langword="true"/> if the element was added to the list. Otherwise, <see langword="false"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when invoked after the serializer has already been constructed.</exception>
            <remarks>
            If the catch-all <see cref="T:Lime.Protocol.Serialization.Newtonsoft.Converters.DocumentJsonConverter"/> is present in the list, the provided <paramref name="jsonConverter"/> will be inserted before it.
            </remarks>
        </member>
        <member name="T:Lime.Protocol.Serialization.TypeUtil">
            <summary>
            Provides metadata information about the types.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.ParseEnum``1(System.String)">
            <summary>
            Gets a cached value 
            for a enum item
            </summary>
            <typeparam name="TEnum"></typeparam>
            <param name="enumName"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.ParseEnum(System.Type,System.String)">
            <summary>
            Gets a cached value 
            for a enum item
            </summary>
            <param name="enumType"></param>
            <param name="enumName"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.GetEnumTypes">
            <summary>
            Gets the assembly enums decorated
            with the DataContract attribute
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.IsDataContractType(System.Type)">
            <summary>
            Indicates if the type is a
            protocol JSON type, decorated
            with the DataContract attribute
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.GetDefaultValue``1">
            <summary>
            Gets the default value for 
            the Type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtil.CreateInstance(System.Type)">
            <summary>
            Creates an instance
            of the type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Serialization.TypeUtilEx">
            <summary>
            Provides metadata about the types.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.GetParseFunc``1">
            <summary>
            Gets the Parse static method of a Type as a func.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.GetFormattedParseFunc``1">
            <summary>
            Gets the Parse static method of a Type as a func.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.GetParseFuncForType(System.Type)">
            <summary>
            Gets the Parse static method of a Type as a func.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.GetFormattedParseFuncForType(System.Type)">
            <summary>
            Gets the Parse static method of a Type as a func.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.ParseFuncAdapter``1(System.Func{System.String,``0})">
            <summary>
            Utility function to adapt a typed Func to a object one.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parseFunc">The parse function.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.FormattedParseFuncAdapter``1(System.Func{System.String,System.IFormatProvider,``0})">
            <summary>
            Utility function to adapt a typed Func to a object one.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parseFunc">The parse function.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.TryParseString(System.String,System.Type,System.Object@,System.IFormatProvider,System.StringSplitOptions)">
            <summary>
            Try parses the string to a object of the specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.BuildGetAccessor(System.Reflection.PropertyInfo)">
            <summary>
            Build a delegate to get a property value of a class.
            </summary>
            <a href="http://stackoverflow.com/questions/10820453/reflection-performance-create-delegate-properties-c"/>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.BuildGetAccessor(System.Reflection.MethodInfo)">
            <summary>
            Build a delegate to get a property value of a class.
            </summary>
            <a href="http://stackoverflow.com/questions/10820453/reflection-performance-create-delegate-properties-c"/>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.BuildSetAccessor(System.Reflection.PropertyInfo)">
            <summary>
            Build a delegate to set a property value of a class.
            </summary>
            <a href="http://stackoverflow.com/questions/10820453/reflection-performance-create-delegate-properties-c"/>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Serialization.TypeUtilEx.BuildSetAccessor(System.Reflection.MethodInfo)">
            <summary>
            Build a delegate to set a property value of a class.
            </summary>
            <a href="http://stackoverflow.com/questions/10820453/reflection-performance-create-delegate-properties-c"/>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Server.AggregateTransportListener">
            <summary>
            Implements a <see cref="T:Lime.Protocol.Server.ITransportListener"/> aggregator that allows multiple transports to be listened as one.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.AuthenticationResult">
            <summary>
            Represents the result of a session authentication.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Server.AuthenticationResult.DomainRole">
            <summary>
            The domain role for the specified node.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Server.AuthenticationResult.Roundtrip">
            <summary>
            The authentication roundtrip.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.INodeRegistry">
            <summary>
            Defines a service to register channel nodes instances for the server.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.INodeRegistry.TryRegisterAsync(Lime.Protocol.Node,Lime.Protocol.Server.IServerChannel,System.Threading.CancellationToken)">
            <summary>
            Try register a node channel. If success, it should return the registered node address; otherwise, returns null.
            Note that the returned node instance may be different from the provided in the parameters.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.INodeRegistry.GetAsync(Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Get a channel for the provided node address.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.INodeRegistry.UnregisterAsync(Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Unregister a channel for the node. 
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.IServer">
            <summary>
            Defines a basic server infrastructure.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.IServerChannel">
            <summary>
            Defines the communication channel
            between a server and a node
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.ReceiveNewSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a new session envelope
            from the client node.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.NegotiateSessionAsync(Lime.Protocol.SessionCompression[],Lime.Protocol.SessionEncryption[],System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a negotiate session envelope to the node with the available options and awaits for the client selected option.
            </summary>
            <param name="compressionOptions">The session compression options.</param>
            <param name="encryptionOptions">The encryption options.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>
            A negotiating session envelope with the client node selected options.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.SendNegotiatingSessionAsync(Lime.Protocol.SessionCompression,Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Send a negotiate session envelope to confirm the session negotiation options.
            </summary>
            <param name="sessionCompression">The session compression option</param>
            <param name="sessionEncryption">The session encryption option</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.AuthenticateSessionAsync(Lime.Protocol.Security.AuthenticationScheme[],System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends an authenticating envelope to the node with the available options and awaits for the client authentication.
            </summary>
            <param name="schemeOptions">The scheme options.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>
            A authenticating session envelope with the authentication information.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.AuthenticateSessionAsync(Lime.Protocol.Security.Authentication,System.Threading.CancellationToken)">
            <summary>
            Sends authentication round-trip information to the connected node and awaits for the client authentication.
            </summary>
            <param name="authenticationRoundtrip">The authentication round-trip data.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>
            A authenticating session envelope with the authentication information.
            </returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.SendEstablishedSessionAsync(Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a finished session envelope to the node to communicate the end of the session.
            </summary>
            <param name="node">The node.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.ReceiveFinishingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a finishing session envelope from the client node.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.SendFinishedSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a finished session envelope to the node to communicate the end of the session and closes the transport.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IServerChannel.SendFailedSessionAsync(Lime.Protocol.Reason,System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a failed session envelope to the node to communicate the finished session and closes the transport.
            </summary>
            <param name="reason">The reason.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IStartable.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Start listening for connections.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.StartableExtensions.StartAsync(Lime.Protocol.Server.IStartable)">
            <summary>
            Start listening for connections.
            </summary>             
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.IStoppable.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Stops the tranport listener.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.StoppableExtensions.StopAsync(Lime.Protocol.Server.IStoppable)">
            <summary>
            Stops the tranport listener.
            </summary>             
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Server.ITransportListener">
            <summary>
            Defines a listener interface for the transports.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Server.ITransportListener.ListenerUris">
            <summary>
            Gets the transport listener URIs.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.ITransportListener.AcceptTransportAsync(System.Threading.CancellationToken)">
            <summary>
            Accepts a new transport connection.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Server.NodeRegistry">
            <summary>
            Implements a simple in-memory <see cref="T:Lime.Protocol.Server.INodeRegistry"/>.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.Server">
            <summary>
            Simple generic server for receiving connections and processing envelopes.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Server.ServerChannel">
            <summary>
            Defines a communication channel between a server and a node.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.#ctor(System.String,Lime.Protocol.Node,Lime.Protocol.Network.ITransport,System.TimeSpan,System.Int32,System.Boolean,System.Boolean,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},Lime.Protocol.Network.IChannelCommandProcessor)">
            <summary>
            Initializes a new instance of the <a href="ServerChannel" /> class.
            </summary>
            <param name="sessionId">The session identifier.</param>
            <param name="localNode">The server node.</param>
            <param name="transport">The transport to be used by the channel.</param>
            <param name="sendTimeout">The channel send timeout. Each send operation must be completed in the specified timeout or it will be canceled.</param>
            <param name="envelopeBufferSize">The number of envelopes to be buffered internally by the channel in the receive operations. If this limit is reached, the channel will not consume the transport until the buffer is consumed by the receive operations.</param>
            <param name="fillEnvelopeRecipients">if set to <c>true</c> [fill envelope recipients].</param>
            <param name="autoReplyPings">Indicates if the channel should reply automatically to ping request commands. In this case, the ping command are not returned by the ReceiveCommandAsync method.</param>
            <param name="remotePingInterval">The interval to ping the remote party.</param>
            <param name="remoteIdleTimeout">The timeout to close the channel due to inactivity.</param>
            <param name="consumeTimeout">The channel consume timeout. Each envelope received from the transport must be consumed in the specified interval or it will cause the channel to be closed.</param>
            <param name="closeTimeout">The channel close timeout.</param>
            <param name="channelCommandProcessor">The channel command processor.</param>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.ReceiveNewSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a new session envelope from the client node.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.NegotiateSessionAsync(Lime.Protocol.SessionCompression[],Lime.Protocol.SessionEncryption[],System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a negotiate session envelope to the node with the available options and awaits for the client selected option.
            </summary>
            <param name="cancellationToken"></param>
            <param name="compressionOptions">The session compression options.</param>
            <param name="encryptionOptions"></param>
            <returns>
            A negotiating session envelope with the client node selected options.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            compressionOptions
            or
            encryptionOptions
            </exception>
            <exception cref="T:System.ArgumentException">
            No available options for compression negotiation
            or
            No available options for encryption negotiation
            </exception>
            <exception cref="T:System.InvalidOperationException">Cannot await for a session response since there's already a listener.</exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.SendNegotiatingSessionAsync(Lime.Protocol.SessionCompression,Lime.Protocol.SessionEncryption,System.Threading.CancellationToken)">
            <summary>
            Send a negotiate session envelope to the remote node to confirm the session negotiation options.
            </summary>
            <param name="sessionCompression">The session compression option</param>
            <param name="sessionEncryption">The session encryption option</param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.AuthenticateSessionAsync(Lime.Protocol.Security.AuthenticationScheme[],System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends an authenticate envelope to the node with the available options and awaits for the client authentication.
            </summary>
            <param name="cancellationToken"></param>
            <param name="schemeOptions"></param>
            <returns>
            An authenticating session envelope with the authentication information.
            </returns>
            <exception cref="T:System.ArgumentNullException">authentication</exception>
            <exception cref="T:System.ArgumentException">No available options for authentication</exception>
            <exception cref="T:System.InvalidOperationException">Cannot await for a session response since there's already a listener.</exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.AuthenticateSessionAsync(Lime.Protocol.Security.Authentication,System.Threading.CancellationToken)">
            <summary>
            Sends authentication round-trip information to the connected node and awaits for the client authentication.
            </summary>
            <param name="authenticationRoundtrip">The authentication round-trip data.</param>
            <param name="cancellationToken"></param>
            <returns>
            A authenticating session envelope with the authentication information.
            </returns>
            <exception cref="T:System.ArgumentNullException">authenticationRoundtrip</exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.SendEstablishedSessionAsync(Lime.Protocol.Node,System.Threading.CancellationToken)">
            <summary>
            Changes the session state to the established state and sends a session envelope to the node to communicate the establishment of the session.
            </summary>
            <param name="node"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">node</exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.ReceiveFinishingSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a finishing session envelope from the client node.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">
            Cannot await for a session response since there's already a listener.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.SendFinishedSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a finished session envelope to the node to communicate the end of the session and closes the transport.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.SendFailedSessionAsync(Lime.Protocol.Reason,System.Threading.CancellationToken)">
            <summary>
            Changes the session state and sends a failed session envelope to the node to communicate the finished session and closes the transport.
            </summary>
            <param name="reason"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">reason</exception>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannel.ReceiveSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Receives a session from the remote node.
            Avoid to use this method directly. Instead, use the Server or Client channel methods.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.Server.ServerChannelExtensions.EstablishSessionAsync(Lime.Protocol.Server.IServerChannel,Lime.Protocol.SessionCompression[],Lime.Protocol.SessionEncryption[],Lime.Protocol.Security.AuthenticationScheme[],System.Func{Lime.Protocol.Identity,Lime.Protocol.Security.Authentication,System.Threading.CancellationToken,System.Threading.Tasks.Task{Lime.Protocol.Server.AuthenticationResult}},System.Func{Lime.Protocol.Node,Lime.Protocol.Server.IServerChannel,System.Threading.CancellationToken,System.Threading.Tasks.Task{Lime.Protocol.Node}},System.Threading.CancellationToken)">
            <summary>
            Establishes a server channel with transport options negotiation and authentication.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Session">
            <summary>
            Allows the configuration and establishment of the communication channel between nodes. 
            </summary>
        </member>
        <member name="M:Lime.Protocol.Session.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lime.Protocol.Session"/> class.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.State">
            <summary>
            Informs or changes the state of a session. 
            Only the server can change the session state, but the client can request the state transition. 
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.EncryptionOptions">
            <summary>
            Encryption options provided by the server during the session negotiation.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.Encryption">
            <summary>
            The encryption option selected for the session. 
            This property is provided by the client in the 
            negotiation and by the server in the confirmation 
            after that.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.CompressionOptions">
            <summary>
            Compression options provided by the 
            server during the session negotiation.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.Compression">
            <summary>
            The compression option selected for the session. 
            This property is provided by the client in the 
            negotiation and by the server in the confirmation 
            after that.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.SchemeOptions">
            <summary>
            List of available authentication schemas 
            for session authentication provided by the server.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.Scheme">
            <summary>
            The authentication scheme option selected 
            for the session. This property must be present 
            if the property authentication is defined.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.Authentication">
            <summary>
            Authentication data, related to the selected schema. 
            Information like password sent by the client or 
            roundtrip data sent by the server.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Session.Reason">
            <summary>
            In cases where the client receives a session with 
            failed state, this property should provide more 
            details about the problem.
            </summary>
        </member>
        <member name="T:Lime.Protocol.SessionCompression">
            <summary>
            Defines the valid session compression values.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionCompression.None">
            <summary>
            The session is not compressed.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionCompression.GZip">
            <summary>
            The session is using the GZip 
            algorithm for compression.
            </summary>
        </member>
        <member name="T:Lime.Protocol.SessionEncryption">
            <summary>
            Defines the valid session encryption values.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionEncryption.None">
            <summary>
            The session is not encrypted.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionEncryption.TLS">
            <summary>
            The session is encrypted by TLS 
            (Transport Layer Security).
            </summary>
        </member>
        <member name="T:Lime.Protocol.SessionState">
            <summary>
            Defines the supported session states
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.New">
            <summary>
            The session is new and doesn't exists an 
            established context. It is sent by a client 
            node to start a session with a server.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Negotiating">
            <summary>
            The server and the client are negotiating the 
            session options, like cryptography and compression. 
            The server sends to the client the options (if available) 
            and the client chooses the desired options. 
            If there's no options (for instance, if the connection 
            is already encrypted or the transport protocol doesn't 
            support these options), the server SHOULD skip the negotiation.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Authenticating">
            <summary>
            The session is being authenticated. The server sends to 
            the client the available authentication schemes list and 
            the client must choose one and send the specific authentication 
            data. The authentication can occurs in multiple roundtrips, 
            according to the selected schema.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Established">
            <summary>
            The session is active and it is possible to send and receive 
            messages and commands. The server sends this state 
            after the session was authenticated.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Finishing">
            <summary>
            The client node is requesting to 
            the server to finish the session.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Finished">
            <summary>
            The session was gracefully 
            finished by the server.
            </summary>
        </member>
        <member name="F:Lime.Protocol.SessionState.Failed">
            <summary>
            A problem occurred while the session was established, under 
            negotiation or authentication and it was closed by the server. 
            In this case, the property reason MUST be present to provide 
            more details about the problem.
            </summary>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.ToCamelCase(System.String)">
            <summary>
            Converts the string to the
            camelCase representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.ToTitleCase(System.String)">
            <summary>
            Converts the string to the
            TitleCase (or PascalCase) representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.ToBase64(System.String)">
            <summary>
            Gets a Base64 representation of a string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.FromBase64(System.String)">
            <summary>
            Converts from a Base64 string 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.IsNullOrWhiteSpace(System.String)">
            <summary>
            Indicates whether a specified string is null, empty, or consists only of white-space characters.
            </summary>
            
            <returns>
            true if the <paramref name="value"/> parameter is null or <see cref="F:System.String.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
            </returns>
            <param name="value">The string to test.</param>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>
            Indicates whether the specified string is null or an <see cref="F:System.String.Empty"/> string.
            </summary>
            
            <returns>
            true if the <paramref name="value"/> parameter is null or an empty string (""); otherwise, false.
            </returns>
            <param name="value">The string to test. </param><filterpriority>1</filterpriority>
        </member>
        <member name="M:Lime.Protocol.StringExtensions.TrimFirstDomainLabel(System.String)">
            <summary>
            Strip the first label of a domain address.
            </summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Tracing.ActivityExtensions">
            <summary>
            Extensions methods for <see cref="T:System.Diagnostics.Activity"/> class to make it easier to create and start activities based on <see cref="T:Lime.Protocol.Envelope"/> and other Lime objects.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.CopyTraceParent(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Copies the Trace Context from a dictionary to another.
            </summary>
            <param name="from">Dictionary to copy the Trace Context from if available</param>
            <param name="to">Dictionary to copy the Trace Context to</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.CopyTraceParent(Lime.Protocol.Envelope,Lime.Protocol.Envelope)">
            <summary>
            Checks if the dictionary contains the W3C Trace Context.
            </summary>
            <param name="from">Envelope to copy the Trace Context from if available</param>
            <param name="to">Envelope to copy the Trace Context to</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.ContainsW3CTraceContext(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Checks if the dictionary contains the W3C Trace Context.
            </summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.ContainsW3CTraceContext(Lime.Protocol.Envelope)">
            <summary>
            Checks if Envelope's metadata contains the W3C Trace Context.
            </summary>
            <param name="envelope">The envelope to check for the Trace Context</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.StartActivity(System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.Diagnostics.ActivityKind,System.Diagnostics.ActivitySource,System.Boolean)">
            <summary>
            Creates and starts a new activity based on the current activity or a dictionary containing the W3C Trace Context.
            <param name="dictionary">The dictionary to retrieve W3C Trace Context</param>
            <param name="name">The name of the activity</param>
            <param name="kind">The <see cref="T:System.Diagnostics.ActivityKind">ActivityKind</see> to be used in the new Activity</param>
            <param name="activitySource">The <see cref="T:System.Diagnostics.ActivitySource">ActivitySource</see> to be used to create the new Activity. It will use <see cref="F:Lime.Protocol.Tracing.LimeActivitySource.Instance">LimeTracing.ActivitySource</see> if not specified.</param>
            <param name="prioritizeDictionaryActivity">If true and if the dictionary contains a valid W3C Trace Context, it will be used as context instead of the current Activity</param>
            </summary>
            <remarks>
            It will not set new trace context to the dictionary.
            If there is a current active Activity, it will be used as parent of the new Activity instead of the dictionary trace context, you can modify this behavior with the ignoreCurrentActivity parameter.
            </remarks>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.StartActivity(Lime.Protocol.Envelope,System.String,System.Diagnostics.ActivityKind,System.Diagnostics.ActivitySource,System.Boolean)">
            <summary>
            Creates and starts a new activity based on the current activity or the envelope metadata.
            The newly created Activity will have its parent from the trace parent and trace state of the envelope metadata if available.
            </summary>
            <param name="envelope">The envelope to use as context</param>
            <param name="name">The name of the activity</param>
            <param name="kind">The <see cref="T:System.Diagnostics.ActivityKind">ActivityKind</see> to be used in the new Activity</param>
            <param name="activitySource">The <see cref="T:System.Diagnostics.ActivitySource">ActivitySource</see> to be used to create the new Activity. It will use <see cref="F:Lime.Protocol.Tracing.LimeActivitySource.Instance">LimeTracing.ActivitySource</see> if not specified.</param>
            <param name="prioritizeEnvelopeActivity">If true and if envelope's metadata contains an activity, it will be used as context instead of the current Activity</param>
            <returns>A new Activity created or null if there is no listener on the ActivitySource.</returns>
            <remarks>
            If the envelope is a Command with '/ping' Uri it will always return null.
            If there is a current active Activity, it will be used as parent of the new Activity instead of the dictionary trace context, you can modify this behavior with the ignoreCurrentActivity parameter.
            </remarks>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.InjectTraceParent(System.Diagnostics.Activity,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            It will set the trace parent and trace state of the activity into the dictionary using W3C Trace Context format.
            </summary>
            <param name="activity">The activity to get the trace parent and trace state</param>
            <param name="dictionary">The dictionary to set the trace parent and trace state</param>
            <remarks>
            The dictionary must be mutable.
            </remarks>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.InjectTraceParent(System.Diagnostics.Activity,Lime.Protocol.Envelope)">
            <summary>
            It will set the trace parent and trace state of the activity into envelope's metadata
            </summary>
            <param name="activity">The activity to get the trace parent and trace state</param>
            <param name="envelope">The envelope to set the trace parent and trace state</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.InjectTraceParentIfAbsent(System.Diagnostics.Activity,Lime.Protocol.Envelope)">
            <summary>
            It will set the trace parent and trace state of the activity into envelope's metadata only if the envelope's metadata does not have a trace parent
            </summary>
            <param name="activity">The activity to get the trace parent and trace state</param>
            <param name="envelope">The envelope to set the trace parent and trace state</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetEnvelopeTags(System.Diagnostics.Activity,Lime.Protocol.Envelope)">
            <summary>
            Include envelope tags in the activity
            </summary>
            <param name="activity"></param>
            <param name="envelope"></param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetNotificationTags(System.Diagnostics.Activity,Lime.Protocol.Notification)">
            <summary>
            Include command tags in the activity
            </summary>
            <param name="activity">The current activity to include command info</param>
            <param name="notification">The notification to be traced</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetCommandTags(System.Diagnostics.Activity,Lime.Protocol.Command)">
            <summary>
            Include command tags in the activity
            </summary>
            <param name="activity">The current activity to include command info</param>
            <param name="command">The command to be traced</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetSessionTags(System.Diagnostics.Activity,Lime.Protocol.Session)">
            <summary>
            Include command tags in the activity
            </summary>
            <param name="activity">The current activity to include command info</param>
            <param name="session">The session to be traced</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetMessageTags(System.Diagnostics.Activity,Lime.Protocol.Message)">
            <summary>
            Include command tags in the activity
            </summary>
            <param name="activity">The current activity to include command info</param>
            <param name="message">The message to be traced</param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.GetActivityName(Lime.Protocol.Envelope)">
            <summary>
            Gets a string to be used as activity name based on the envelope type
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetTransportTags(System.Diagnostics.Activity,Lime.Protocol.Network.ITransport)">
            <summary>
            Sets the transport tags in the activity
            </summary>
            <param name="activity"></param>
            <param name="transport"></param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.SetNodeTags(System.Diagnostics.Activity,Lime.Protocol.Node)">
            <summary>
            Sets the node tags in the activity
            </summary>
            <param name="activity"></param>
            <param name="node"></param>
        </member>
        <member name="M:Lime.Protocol.Tracing.ActivityExtensions.AddChannelTags(System.Diagnostics.Activity,Lime.Protocol.Network.IChannel)">
            <summary>
            Sets the channel tags in the activity
            </summary>
            <param name="activity"></param>
            <param name="channel"></param>
        </member>
        <member name="T:Lime.Protocol.Tracing.LimeActivitySource">
            <summary>
            Provides the ActivitySource for the Lime.Protocol
            </summary>
        </member>
        <member name="F:Lime.Protocol.Tracing.LimeActivitySource.LimeProtocol">
            <summary>
            The name of the ActivitySource for the Lime.Protocol
            </summary>
        </member>
        <member name="F:Lime.Protocol.Tracing.LimeActivitySource.Instance">
            <summary>
            Gets the ActivitySource for the Lime.Protocol to be used when creating activities.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Tracing.TraceContext">
            <summary>
            Defines the Trace Context constants.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Tracing.TraceContext.TraceParent">
            <summary>
            The trace parent header name of the W3C trace context.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Tracing.TraceContext.TraceState">
            <summary>
            The trace state header name of the W3C trace context.
            </summary>
        </member>
        <member name="M:Lime.Protocol.TypeExtensions.GetDefaultValue(System.Type)">
            <summary>
            Gets the default value of a Type        
            </summary>
            <a href="http://stackoverflow.com/questions/325426/programmatic-equivalent-of-defaulttype"/>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.IsPingRequest(Lime.Protocol.Command)">
            <summary>
            Indicates if a command is
            a ping request
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.GetResourceUri(Lime.Protocol.Command)">
            <summary>
            Gets the Uri address
            of a command resource
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.DisposeIfDisposable``1(``0)">
            <summary>
            Disposes an object if it is not null
            and it implements IDisposable interface
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.RaiseEvent(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Checks if an event handles is not null and
            raise it if is the case
            </summary>
            <param name="event"></param>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.RaiseEvent``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Checks if an event handles is not null and
            raise it if is the case
            </summary>
            <typeparam name="T"></typeparam>
            <param name="event"></param>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.WithCancellation``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Allow cancellation of non-cancellable tasks
            </summary>
            <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/10/05/how-do-i-cancel-non-cancelable-async-operations.aspx"/>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Allow cancellation of non-cancellable tasks
            </summary>
            <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/10/05/how-do-i-cancel-non-cancelable-async-operations.aspx"/>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.ToCancellationToken(System.TimeSpan)">
            <summary>
            Creates a CancellationToken
            with the specified delay
            </summary>
            <param name="delay">The delay.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.GetIdentity(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Gets the identity value from the certificate subject.
            </summary>
            <param name="certificate"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.GetIdentity(System.Uri)">
            <summary>
            Gets the identity
            associated to the URI
            authority
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.ToCommaSepparate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Transform to a flat string
            with comma sepparate values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.ToSHA1Hash(System.String)">
            <summary>
            Gets a SHA1 hash for the specified string.
            </summary>
            <param name="inputString"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.ToSHA1HashString(System.String)">
            <summary>
            Gets a SHA1 hash for the specified string.
            </summary>
            <param name="inputString"></param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.AsCompletedTask``1(``0)">
            <summary>
            Creates a completed task.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.ToReason(System.Exception)">
            <summary>
            Converts an exception to a general error reason.
            </summary>
            <param name="exception">The exception.</param>
            <returns></returns>
        </member>
        <member name="M:Lime.Protocol.UtilExtensions.AsTask(System.Threading.CancellationToken)">
            <summary>
            Creates a tasks that completes after the passed cancellation token is cancelled.
            http://stackoverflow.com/questions/18670111/task-from-cancellation-token
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Util.AsyncCountdownEvent">
            <summary>
            An async-compatible countdown event.
            Extracted from: http://nitoasyncex.codeplex.com/SourceControl/latest#Source/Nito.AsyncEx (NET4, Win8, SL4, WP75)/AsyncCountdownEvent.cs
            </summary>
        </member>
        <member name="F:Lime.Protocol.Util.AsyncCountdownEvent._tcs">
            <summary>
            The TCS used to signal this event.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Util.AsyncCountdownEvent._count">
            <summary>
            The remaining count on this event.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.#ctor(System.Int32)">
            <summary>
            Creates an async-compatible countdown event.
            </summary>
            <param name="count">The number of signals this event will need before it becomes set. Must be greater than zero.</param>
        </member>
        <member name="P:Lime.Protocol.Util.AsyncCountdownEvent.Id">
            <summary>
            Gets a semi-unique identifier for this asynchronous countdown event.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Util.AsyncCountdownEvent.CurrentCount">
            <summary>
            Gets the current number of remaining signals before this event becomes set.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for this event to be set.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.ModifyCount(System.Int32)">
            <summary>
            Attempts to modify the current count by the specified amount. This method returns <c>false</c> if the new current count value would be invalid, or if the count has already reached zero.
            </summary>
            <param name="signalCount">The amount to change the current count. This may be positive or negative, but not zero.</param>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.TryAddCount(System.Int32)">
            <summary>
            Attempts to add the specified value to the current count. This method returns <c>false</c> if the count is already at zero or if the new count would be greater than <a href="Int32.MaxValue"/>.
            </summary>
            <param name="signalCount">The amount to change the current count. This must be greater than zero.</param>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.TryAddCount">
            <summary>
            Attempts to add one to the current count. This method returns <c>false</c> if the count is already at zero or if the new count would be greater than <a href="Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.TrySignal(System.Int32)">
            <summary>
            Attempts to subtract the specified value from the current count. This method returns <c>false</c> if the count is already at zero or if the new count would be less than zero.
            </summary>
            <param name="signalCount">The amount to change the current count. This must be greater than zero.</param>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.TrySignal">
            <summary>
            Attempts to subtract one from the current count. This method returns <c>false</c> if the count is already at zero or if the new count would be less than zero.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.AddCount(System.Int32)">
            <summary>
            Attempts to add the specified value to the current count. This method throws <a href="InvalidOperationException"/> if the count is already at zero or if the new count would be greater than <a href="Int32.MaxValue"/>.
            </summary>
            <param name="signalCount">The amount to change the current count. This must be greater than zero.</param>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.AddCount">
            <summary>
            Attempts to add one to the current count. This method throws <a href="InvalidOperationException"/> if the count is already at zero or if the new count would be greater than <a href="Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.Signal(System.Int32)">
            <summary>
            Attempts to subtract the specified value from the current count. This method throws <a href="InvalidOperationException"/> if the count is already at zero or if the new count would be less than zero.
            </summary>
            <param name="signalCount">The amount to change the current count. This must be greater than zero.</param>
        </member>
        <member name="M:Lime.Protocol.Util.AsyncCountdownEvent.Signal">
            <summary>
            Attempts to subtract one from the current count. This method throws <a href="InvalidOperationException"/> if the count is already at zero or if the new count would be less than zero.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Util.ChannelUtil">
            <summary>
            Util class for working with channels from the System.Threading.Channels namespace.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.ChannelUtil.CreateForCapacity``1(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Threading.Channels.BoundedChannelFullMode)">
            <summary>
            Creates a <see cref="T:System.Threading.Channels.Channel`1"/> instance accordingly to the provided capacity.
            If greater than 0, the channel will be bounded; otherwise unbounded.
            </summary>
        </member>
        <member name="T:Lime.Protocol.Util.DeferralManager">
            <summary>
            <a href="http://blog.stephencleary.com/2013/02/async-oop-5-events.html"/>
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.ProducerConsumer.CreateAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Creates and starts a task that listens the provided producer and call the consumer until the cancellation is requested.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="producer">The producer func.</param>
            <param name="consumer">The consumer func.</param>
            <param name="cancellationToken">The cancellation token for the consumer task.</param>
            <param name="handleCancellation">Indicates if the <see cref="T:System.OperationCanceledException"/> should be handled if the provided cancellationToken is cancelled.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Lime.Protocol.Util.ProducerExtensions.Consume``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}},System.Threading.CancellationToken)">
            <summary>
            Attach a consumer to the producer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="producer"></param>
            <param name="consumer"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Lime.Protocol.Util.RateGate">
            <summary>
            Used to control the rate of some occurrence per unit of time.
            </summary>
            <remarks>
                <para>
                To control the rate of an action using a <see cref="T:Lime.Protocol.Util.RateGate"/>, 
                code should simply call <see cref="M:Lime.Protocol.Util.RateGate.WaitToProceedAsync"/> prior to 
                performing the action. <see cref="M:Lime.Protocol.Util.RateGate.WaitToProceedAsync"/> will block
                the current thread until the action is allowed based on the rate 
                limit.
                </para>
                <para>
                This class is thread safe. A single <see cref="T:Lime.Protocol.Util.RateGate"/> instance 
                may be used to control the rate of an occurrence across multiple 
                threads.
                </para>
            </remarks>
        </member>
        <member name="P:Lime.Protocol.Util.RateGate.Occurrences">
            <summary>
            Number of occurrences allowed per unit of time.
            </summary>
        </member>
        <member name="P:Lime.Protocol.Util.RateGate.TimeUnitMilliseconds">
            <summary>
            The length of the time unit, in milliseconds.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.RateGate.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a <see cref="T:Lime.Protocol.Util.RateGate"/> with a rate of <paramref name="occurrences"/> 
            per <paramref name="timeUnit"/>.
            </summary>
            <param name="occurrences">Number of occurrences allowed per unit of time.</param>
            <param name="timeUnit">Length of the time unit.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="occurrences"/> or <paramref name="timeUnit"/> is negative.
            </exception>
        </member>
        <member name="M:Lime.Protocol.Util.RateGate.WaitToProceedAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until allowed to proceed or until the
            specified timeout elapses.
            </summary>
            <param name="cancellationToken">The cancellation token for the task</param>
            <returns>true if the thread is allowed to proceed, or false if timed out</returns>
        </member>
        <member name="M:Lime.Protocol.Util.RateGate.WaitToProceedAsync">
            <summary>
            Blocks the current thread indefinitely until allowed to proceed.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.RateGate.Dispose">
            <summary>
            Releases unmanaged resources held by an instance of this class.
            </summary>
        </member>
        <member name="M:Lime.Protocol.Util.RateGate.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged resources held by an instance of this class.
            </summary>
            <param name="isDisposing">Whether this object is being disposed.</param>
        </member>
        <member name="F:Lime.Protocol.Util.TaskUtil.CompletedTask">
            <summary>
            Gets a completed task.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Util.TaskUtil.TrueCompletedTask">
            <summary>
            Gets a completed task with true result.
            </summary>
        </member>
        <member name="F:Lime.Protocol.Util.TaskUtil.FalseCompletedTask">
            <summary>
            Gets a completed task with true result.
            </summary>
        </member>
    </members>
</doc>
